// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: accounts.sql

package postgres

import (
	"context"
	"database/sql"
)

const confirmAccountDiff = `-- name: ConfirmAccountDiff :execrows
UPDATE account_diffs SET
    confirmed=TRUE
WHERE trader_key = $1 AND confirmed = FALSE
`

func (q *Queries) ConfirmAccountDiff(ctx context.Context, traderKey []byte) (int64, error) {
	result, err := q.db.Exec(ctx, confirmAccountDiff, traderKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createAccountDiff = `-- name: CreateAccountDiff :exec

INSERT INTO account_diffs (
    trader_key, token_id, confirmed, value, expiry, auctioneer_key_family,
    auctioneer_key_index, auctioneer_public_key, batch_key, secret, state,
    height_hint, out_point_hash, out_point_index, latest_tx, user_agent,
    version)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
`

type CreateAccountDiffParams struct {
	TraderKey           []byte
	TokenID             []byte
	Confirmed           bool
	Value               int64
	Expiry              int64
	AuctioneerKeyFamily int64
	AuctioneerKeyIndex  int64
	AuctioneerPublicKey []byte
	BatchKey            []byte
	Secret              []byte
	State               int16
	HeightHint          int64
	OutPointHash        []byte
	OutPointIndex       int64
	LatestTx            []byte
	UserAgent           string
	Version             int16
}

// - Account Diff Queries ---
func (q *Queries) CreateAccountDiff(ctx context.Context, arg CreateAccountDiffParams) error {
	_, err := q.db.Exec(ctx, createAccountDiff,
		arg.TraderKey,
		arg.TokenID,
		arg.Confirmed,
		arg.Value,
		arg.Expiry,
		arg.AuctioneerKeyFamily,
		arg.AuctioneerKeyIndex,
		arg.AuctioneerPublicKey,
		arg.BatchKey,
		arg.Secret,
		arg.State,
		arg.HeightHint,
		arg.OutPointHash,
		arg.OutPointIndex,
		arg.LatestTx,
		arg.UserAgent,
		arg.Version,
	)
	return err
}

const createAccountReservation = `-- name: CreateAccountReservation :exec

INSERT INTO account_reservations(
    trader_key, value, auctioneer_key_family, auctioneer_key_index, 
    auctioneer_public_key, initial_batch_key, expiry, height_hint, token_id,
    version)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateAccountReservationParams struct {
	TraderKey           []byte
	Value               int64
	AuctioneerKeyFamily int64
	AuctioneerKeyIndex  int64
	AuctioneerPublicKey []byte
	InitialBatchKey     []byte
	Expiry              int64
	HeightHint          int64
	TokenID             []byte
	Version             int16
}

// - AccountReservation Queries ---
func (q *Queries) CreateAccountReservation(ctx context.Context, arg CreateAccountReservationParams) error {
	_, err := q.db.Exec(ctx, createAccountReservation,
		arg.TraderKey,
		arg.Value,
		arg.AuctioneerKeyFamily,
		arg.AuctioneerKeyIndex,
		arg.AuctioneerPublicKey,
		arg.InitialBatchKey,
		arg.Expiry,
		arg.HeightHint,
		arg.TokenID,
		arg.Version,
	)
	return err
}

const createAuctioneerSnapshot = `-- name: CreateAuctioneerSnapshot :exec
INSERT INTO auctioneer_snapshots(
        batch_key, balance, out_point_hash, out_point_index, version)
VALUES ($1, $2, $3, $4, $5)
`

type CreateAuctioneerSnapshotParams struct {
	BatchKey      []byte
	Balance       int64
	OutPointHash  []byte
	OutPointIndex int64
	Version       int16
}

func (q *Queries) CreateAuctioneerSnapshot(ctx context.Context, arg CreateAuctioneerSnapshotParams) error {
	_, err := q.db.Exec(ctx, createAuctioneerSnapshot,
		arg.BatchKey,
		arg.Balance,
		arg.OutPointHash,
		arg.OutPointIndex,
		arg.Version,
	)
	return err
}

const deleteAccount = `-- name: DeleteAccount :execrows
DELETE FROM accounts
WHERE trader_key=$1
`

func (q *Queries) DeleteAccount(ctx context.Context, traderKey []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccount, traderKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAccountDiff = `-- name: DeleteAccountDiff :execrows
DELETE 
FROM account_diffs
WHERE id = $1
`

func (q *Queries) DeleteAccountDiff(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccountDiff, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAccountReservation = `-- name: DeleteAccountReservation :execrows
DELETE 
FROM account_reservations
WHERE token_id = $1
`

func (q *Queries) DeleteAccountReservation(ctx context.Context, tokenID []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAccountReservation, tokenID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAuctioneerAccount = `-- name: DeleteAuctioneerAccount :execrows
DELETE FROM auctioneer_account
WHERE auctioneer_public_key=$1 AND auctioneer_key_family=$2
`

type DeleteAuctioneerAccountParams struct {
	AuctioneerPublicKey []byte
	AuctioneerKeyFamily int64
}

func (q *Queries) DeleteAuctioneerAccount(ctx context.Context, arg DeleteAuctioneerAccountParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAuctioneerAccount, arg.AuctioneerPublicKey, arg.AuctioneerKeyFamily)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAccount = `-- name: GetAccount :one
SELECT trader_key, token_id, value, expiry, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, batch_key, secret, state, height_hint, out_point_hash, out_point_index, latest_tx, user_agent, version 
FROM accounts
WHERE trader_key = $1
`

func (q *Queries) GetAccount(ctx context.Context, traderKey []byte) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, traderKey)
	var i Account
	err := row.Scan(
		&i.TraderKey,
		&i.TokenID,
		&i.Value,
		&i.Expiry,
		&i.AuctioneerKeyFamily,
		&i.AuctioneerKeyIndex,
		&i.AuctioneerPublicKey,
		&i.BatchKey,
		&i.Secret,
		&i.State,
		&i.HeightHint,
		&i.OutPointHash,
		&i.OutPointIndex,
		&i.LatestTx,
		&i.UserAgent,
		&i.Version,
	)
	return i, err
}

const getAccountDiffByID = `-- name: GetAccountDiffByID :one
SELECT id, trader_key, confirmed, token_id, value, expiry, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, batch_key, secret, state, height_hint, out_point_hash, out_point_index, latest_tx, user_agent, version 
FROM account_diffs
WHERE id = $1
`

func (q *Queries) GetAccountDiffByID(ctx context.Context, id int64) (AccountDiff, error) {
	row := q.db.QueryRow(ctx, getAccountDiffByID, id)
	var i AccountDiff
	err := row.Scan(
		&i.ID,
		&i.TraderKey,
		&i.Confirmed,
		&i.TokenID,
		&i.Value,
		&i.Expiry,
		&i.AuctioneerKeyFamily,
		&i.AuctioneerKeyIndex,
		&i.AuctioneerPublicKey,
		&i.BatchKey,
		&i.Secret,
		&i.State,
		&i.HeightHint,
		&i.OutPointHash,
		&i.OutPointIndex,
		&i.LatestTx,
		&i.UserAgent,
		&i.Version,
	)
	return i, err
}

const getAccountDiffs = `-- name: GetAccountDiffs :many
SELECT id, trader_key, confirmed, token_id, value, expiry, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, batch_key, secret, state, height_hint, out_point_hash, out_point_index, latest_tx, user_agent, version 
FROM account_diffs
ORDER BY id
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetAccountDiffsParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetAccountDiffs(ctx context.Context, arg GetAccountDiffsParams) ([]AccountDiff, error) {
	rows, err := q.db.Query(ctx, getAccountDiffs, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountDiff
	for rows.Next() {
		var i AccountDiff
		if err := rows.Scan(
			&i.ID,
			&i.TraderKey,
			&i.Confirmed,
			&i.TokenID,
			&i.Value,
			&i.Expiry,
			&i.AuctioneerKeyFamily,
			&i.AuctioneerKeyIndex,
			&i.AuctioneerPublicKey,
			&i.BatchKey,
			&i.Secret,
			&i.State,
			&i.HeightHint,
			&i.OutPointHash,
			&i.OutPointIndex,
			&i.LatestTx,
			&i.UserAgent,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountDiffsByTraderID = `-- name: GetAccountDiffsByTraderID :many
SELECT id, trader_key, confirmed, token_id, value, expiry, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, batch_key, secret, state, height_hint, out_point_hash, out_point_index, latest_tx, user_agent, version 
FROM account_diffs
WHERE trader_key = $1
`

func (q *Queries) GetAccountDiffsByTraderID(ctx context.Context, traderKey []byte) ([]AccountDiff, error) {
	rows, err := q.db.Query(ctx, getAccountDiffsByTraderID, traderKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountDiff
	for rows.Next() {
		var i AccountDiff
		if err := rows.Scan(
			&i.ID,
			&i.TraderKey,
			&i.Confirmed,
			&i.TokenID,
			&i.Value,
			&i.Expiry,
			&i.AuctioneerKeyFamily,
			&i.AuctioneerKeyIndex,
			&i.AuctioneerPublicKey,
			&i.BatchKey,
			&i.Secret,
			&i.State,
			&i.HeightHint,
			&i.OutPointHash,
			&i.OutPointIndex,
			&i.LatestTx,
			&i.UserAgent,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountReservationByTokenID = `-- name: GetAccountReservationByTokenID :one
SELECT trader_key, value, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, initial_batch_key, expiry, height_hint, token_id, version 
FROM account_reservations
WHERE token_id = $1
`

func (q *Queries) GetAccountReservationByTokenID(ctx context.Context, tokenID []byte) (AccountReservation, error) {
	row := q.db.QueryRow(ctx, getAccountReservationByTokenID, tokenID)
	var i AccountReservation
	err := row.Scan(
		&i.TraderKey,
		&i.Value,
		&i.AuctioneerKeyFamily,
		&i.AuctioneerKeyIndex,
		&i.AuctioneerPublicKey,
		&i.InitialBatchKey,
		&i.Expiry,
		&i.HeightHint,
		&i.TokenID,
		&i.Version,
	)
	return i, err
}

const getAccountReservationByTraderKey = `-- name: GetAccountReservationByTraderKey :one
SELECT trader_key, value, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, initial_batch_key, expiry, height_hint, token_id, version 
FROM account_reservations
WHERE trader_key = $1
`

func (q *Queries) GetAccountReservationByTraderKey(ctx context.Context, traderKey []byte) (AccountReservation, error) {
	row := q.db.QueryRow(ctx, getAccountReservationByTraderKey, traderKey)
	var i AccountReservation
	err := row.Scan(
		&i.TraderKey,
		&i.Value,
		&i.AuctioneerKeyFamily,
		&i.AuctioneerKeyIndex,
		&i.AuctioneerPublicKey,
		&i.InitialBatchKey,
		&i.Expiry,
		&i.HeightHint,
		&i.TokenID,
		&i.Version,
	)
	return i, err
}

const getAccountReservations = `-- name: GetAccountReservations :many
SELECT trader_key, value, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, initial_batch_key, expiry, height_hint, token_id, version 
FROM account_reservations
ORDER BY token_id
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetAccountReservationsParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetAccountReservations(ctx context.Context, arg GetAccountReservationsParams) ([]AccountReservation, error) {
	rows, err := q.db.Query(ctx, getAccountReservations, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountReservation
	for rows.Next() {
		var i AccountReservation
		if err := rows.Scan(
			&i.TraderKey,
			&i.Value,
			&i.AuctioneerKeyFamily,
			&i.AuctioneerKeyIndex,
			&i.AuctioneerPublicKey,
			&i.InitialBatchKey,
			&i.Expiry,
			&i.HeightHint,
			&i.TokenID,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccounts = `-- name: GetAccounts :many
SELECT trader_key, token_id, value, expiry, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, batch_key, secret, state, height_hint, out_point_hash, out_point_index, latest_tx, user_agent, version 
FROM accounts
ORDER BY trader_key
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetAccountsParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAccounts, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.TraderKey,
			&i.TokenID,
			&i.Value,
			&i.Expiry,
			&i.AuctioneerKeyFamily,
			&i.AuctioneerKeyIndex,
			&i.AuctioneerPublicKey,
			&i.BatchKey,
			&i.Secret,
			&i.State,
			&i.HeightHint,
			&i.OutPointHash,
			&i.OutPointIndex,
			&i.LatestTx,
			&i.UserAgent,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccoutsCount = `-- name: GetAccoutsCount :one
SELECT COUNT(*)
FROM accounts
`

func (q *Queries) GetAccoutsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAccoutsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAuctioneerAccount = `-- name: GetAuctioneerAccount :one
SELECT balance, batch_key, is_pending, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, out_point_hash, out_point_index, version 
FROM auctioneer_account
`

func (q *Queries) GetAuctioneerAccount(ctx context.Context) (AuctioneerAccount, error) {
	row := q.db.QueryRow(ctx, getAuctioneerAccount)
	var i AuctioneerAccount
	err := row.Scan(
		&i.Balance,
		&i.BatchKey,
		&i.IsPending,
		&i.AuctioneerKeyFamily,
		&i.AuctioneerKeyIndex,
		&i.AuctioneerPublicKey,
		&i.OutPointHash,
		&i.OutPointIndex,
		&i.Version,
	)
	return i, err
}

const getAuctioneerSnapshotByDate = `-- name: GetAuctioneerSnapshotByDate :one
SELECT a.batch_key, a.balance, a.out_point_hash, a.out_point_index, a.version
FROM auctioneer_snapshots a JOIN batches b ON a.batch_key = b.batch_key
WHERE b.created_at <= $1
ORDER BY b.created_at DESC
LIMIT 1
`

func (q *Queries) GetAuctioneerSnapshotByDate(ctx context.Context, createdAt sql.NullTime) (AuctioneerSnapshot, error) {
	row := q.db.QueryRow(ctx, getAuctioneerSnapshotByDate, createdAt)
	var i AuctioneerSnapshot
	err := row.Scan(
		&i.BatchKey,
		&i.Balance,
		&i.OutPointHash,
		&i.OutPointIndex,
		&i.Version,
	)
	return i, err
}

const getNotConfirmedAccountDiff = `-- name: GetNotConfirmedAccountDiff :one
SELECT id, trader_key, confirmed, token_id, value, expiry, auctioneer_key_family, auctioneer_key_index, auctioneer_public_key, batch_key, secret, state, height_hint, out_point_hash, out_point_index, latest_tx, user_agent, version 
FROM account_diffs
WHERE trader_key = $1 AND confirmed = FALSE
`

func (q *Queries) GetNotConfirmedAccountDiff(ctx context.Context, traderKey []byte) (AccountDiff, error) {
	row := q.db.QueryRow(ctx, getNotConfirmedAccountDiff, traderKey)
	var i AccountDiff
	err := row.Scan(
		&i.ID,
		&i.TraderKey,
		&i.Confirmed,
		&i.TokenID,
		&i.Value,
		&i.Expiry,
		&i.AuctioneerKeyFamily,
		&i.AuctioneerKeyIndex,
		&i.AuctioneerPublicKey,
		&i.BatchKey,
		&i.Secret,
		&i.State,
		&i.HeightHint,
		&i.OutPointHash,
		&i.OutPointIndex,
		&i.LatestTx,
		&i.UserAgent,
		&i.Version,
	)
	return i, err
}

const updateAccountDiff = `-- name: UpdateAccountDiff :exec
UPDATE account_diffs SET 
    trader_key=$2, token_id=$3, confirmed=$4, value=$5, expiry=$6, 
    auctioneer_key_family=$7, auctioneer_key_index=$8, auctioneer_public_key=$9,
    batch_key=$10, secret=$11, state=$12, height_hint=$13, out_point_hash=$14, 
    out_point_index=$15, latest_tx=$16, user_agent=$17, version=$18
WHERE id=$1
`

type UpdateAccountDiffParams struct {
	ID                  int64
	TraderKey           []byte
	TokenID             []byte
	Confirmed           bool
	Value               int64
	Expiry              int64
	AuctioneerKeyFamily int64
	AuctioneerKeyIndex  int64
	AuctioneerPublicKey []byte
	BatchKey            []byte
	Secret              []byte
	State               int16
	HeightHint          int64
	OutPointHash        []byte
	OutPointIndex       int64
	LatestTx            []byte
	UserAgent           string
	Version             int16
}

func (q *Queries) UpdateAccountDiff(ctx context.Context, arg UpdateAccountDiffParams) error {
	_, err := q.db.Exec(ctx, updateAccountDiff,
		arg.ID,
		arg.TraderKey,
		arg.TokenID,
		arg.Confirmed,
		arg.Value,
		arg.Expiry,
		arg.AuctioneerKeyFamily,
		arg.AuctioneerKeyIndex,
		arg.AuctioneerPublicKey,
		arg.BatchKey,
		arg.Secret,
		arg.State,
		arg.HeightHint,
		arg.OutPointHash,
		arg.OutPointIndex,
		arg.LatestTx,
		arg.UserAgent,
		arg.Version,
	)
	return err
}

const upsertAccount = `-- name: UpsertAccount :exec

INSERT INTO accounts (
    trader_key, token_id, value, expiry, auctioneer_key_family,
    auctioneer_key_index, auctioneer_public_key, batch_key, secret, state,
    height_hint, out_point_hash, out_point_index, latest_tx, user_agent,
    version)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
ON CONFLICT (trader_key)
DO UPDATE SET token_id=$2, value=$3, expiry=$4, auctioneer_key_family=$5,
    auctioneer_key_index=$6, auctioneer_public_key=$7, batch_key=$8, secret=$9,
    state=$10, height_hint=$11, out_point_hash=$12, out_point_index=$13, 
    latest_tx=$14, user_agent=$15, version=$16
`

type UpsertAccountParams struct {
	TraderKey           []byte
	TokenID             []byte
	Value               int64
	Expiry              int64
	AuctioneerKeyFamily int64
	AuctioneerKeyIndex  int64
	AuctioneerPublicKey []byte
	BatchKey            []byte
	Secret              []byte
	State               int16
	HeightHint          int64
	OutPointHash        []byte
	OutPointIndex       int64
	LatestTx            []byte
	UserAgent           string
	Version             int16
}

// - Account Queries ---
func (q *Queries) UpsertAccount(ctx context.Context, arg UpsertAccountParams) error {
	_, err := q.db.Exec(ctx, upsertAccount,
		arg.TraderKey,
		arg.TokenID,
		arg.Value,
		arg.Expiry,
		arg.AuctioneerKeyFamily,
		arg.AuctioneerKeyIndex,
		arg.AuctioneerPublicKey,
		arg.BatchKey,
		arg.Secret,
		arg.State,
		arg.HeightHint,
		arg.OutPointHash,
		arg.OutPointIndex,
		arg.LatestTx,
		arg.UserAgent,
		arg.Version,
	)
	return err
}

const upsertAuctioneerAccount = `-- name: UpsertAuctioneerAccount :exec

INSERT INTO auctioneer_account(
    balance, batch_key, is_pending, auctioneer_key_family, auctioneer_key_index,
    auctioneer_public_key, out_point_hash, out_point_index, version)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (auctioneer_public_key, auctioneer_key_family)
DO UPDATE SET balance=$1, batch_key=$2, is_pending=$3, auctioneer_key_index=$5,
    out_point_hash=$7, out_point_index=$8, version=$9
`

type UpsertAuctioneerAccountParams struct {
	Balance             int64
	BatchKey            []byte
	IsPending           bool
	AuctioneerKeyFamily int64
	AuctioneerKeyIndex  int64
	AuctioneerPublicKey []byte
	OutPointHash        []byte
	OutPointIndex       int64
	Version             int16
}

// - AuctioneerAccount Queries ---
func (q *Queries) UpsertAuctioneerAccount(ctx context.Context, arg UpsertAuctioneerAccountParams) error {
	_, err := q.db.Exec(ctx, upsertAuctioneerAccount,
		arg.Balance,
		arg.BatchKey,
		arg.IsPending,
		arg.AuctioneerKeyFamily,
		arg.AuctioneerKeyIndex,
		arg.AuctioneerPublicKey,
		arg.OutPointHash,
		arg.OutPointIndex,
		arg.Version,
	)
	return err
}
