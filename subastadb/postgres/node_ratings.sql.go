// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: node_ratings.sql

package postgres

import (
	"context"
)

const deleteNodeRating = `-- name: DeleteNodeRating :execrows
DELETE
FROM node_ratings
WHERE node_key=$1
`

func (q *Queries) DeleteNodeRating(ctx context.Context, nodeKey []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNodeRating, nodeKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getNodeRating = `-- name: GetNodeRating :one
SELECT node_key, node_tier
FROM node_ratings
WHERE node_key = $1
`

func (q *Queries) GetNodeRating(ctx context.Context, nodeKey []byte) (NodeRating, error) {
	row := q.db.QueryRow(ctx, getNodeRating, nodeKey)
	var i NodeRating
	err := row.Scan(&i.NodeKey, &i.NodeTier)
	return i, err
}

const getNodeRatings = `-- name: GetNodeRatings :many
SELECT node_key, node_tier
FROM node_ratings
ORDER BY node_key
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetNodeRatingsParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetNodeRatings(ctx context.Context, arg GetNodeRatingsParams) ([]NodeRating, error) {
	rows, err := q.db.Query(ctx, getNodeRatings, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeRating
	for rows.Next() {
		var i NodeRating
		if err := rows.Scan(&i.NodeKey, &i.NodeTier); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertNodeRating = `-- name: UpsertNodeRating :exec

INSERT INTO node_ratings(node_key, node_tier) 
VALUES ($1, $2)
ON CONFLICT (node_key) 
DO UPDATE SET node_tier=$2
`

type UpsertNodeRatingParams struct {
	NodeKey  []byte
	NodeTier int64
}

// - Node Rating Queries ---
func (q *Queries) UpsertNodeRating(ctx context.Context, arg UpsertNodeRatingParams) error {
	_, err := q.db.Exec(ctx, upsertNodeRating, arg.NodeKey, arg.NodeTier)
	return err
}
