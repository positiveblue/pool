// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: orders.sql

package postgres

import (
	"context"
	"database/sql"
)

type CreateOrderAllowedNodeIdsParams struct {
	Nonce   []byte
	NodeKey []byte
	Allowed bool
}

const createOrderAsk = `-- name: CreateOrderAsk :exec

INSERT INTO order_ask(
        nonce, channel_announcement_constraints, 
        channel_confirmation_constraints
) VALUES ($1, $2, $3)
`

type CreateOrderAskParams struct {
	Nonce                          []byte
	ChannelAnnouncementConstraints int16
	ChannelConfirmationConstraints int16
}

// - Order ask Queries ---
func (q *Queries) CreateOrderAsk(ctx context.Context, arg CreateOrderAskParams) error {
	_, err := q.db.Exec(ctx, createOrderAsk, arg.Nonce, arg.ChannelAnnouncementConstraints, arg.ChannelConfirmationConstraints)
	return err
}

const createOrderBid = `-- name: CreateOrderBid :exec

INSERT INTO order_bid(
        nonce, min_node_tier, self_chan_balance, is_sidecar, 
        unannounced_channel, zero_conf_channel
) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateOrderBidParams struct {
	Nonce              []byte
	MinNodeTier        int64
	SelfChanBalance    int64
	IsSidecar          bool
	UnannouncedChannel bool
	ZeroConfChannel    bool
}

// - Order bid Queries ---
func (q *Queries) CreateOrderBid(ctx context.Context, arg CreateOrderBidParams) error {
	_, err := q.db.Exec(ctx, createOrderBid,
		arg.Nonce,
		arg.MinNodeTier,
		arg.SelfChanBalance,
		arg.IsSidecar,
		arg.UnannouncedChannel,
		arg.ZeroConfChannel,
	)
	return err
}

type CreateOrderNetworkAddressParams struct {
	Nonce   []byte
	Network string
	Address string
}

const deleteOrder = `-- name: DeleteOrder :execrows
DELETE 
FROM orders
WHERE nonce=$1
`

func (q *Queries) DeleteOrder(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrder, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderAllowedNodeIds = `-- name: DeleteOrderAllowedNodeIds :execrows
DELETE 
FROM order_allowed_node_ids
WHERE nonce = $1
`

func (q *Queries) DeleteOrderAllowedNodeIds(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderAllowedNodeIds, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderAsk = `-- name: DeleteOrderAsk :execrows
DELETE
FROM order_ask
WHERE nonce=$1
`

func (q *Queries) DeleteOrderAsk(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderAsk, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderBid = `-- name: DeleteOrderBid :execrows
DELETE
FROM order_bid
WHERE nonce=$1
`

func (q *Queries) DeleteOrderBid(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderBid, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderNetworkAddresses = `-- name: DeleteOrderNetworkAddresses :execrows
DELETE 
FROM order_node_network_addresses
WHERE nonce=$1
`

func (q *Queries) DeleteOrderNetworkAddresses(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderNetworkAddresses, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getOrderAllowedNodeIds = `-- name: GetOrderAllowedNodeIds :many
SELECT nonce, node_key, allowed 
FROM order_allowed_node_ids
WHERE nonce = ANY($1::BYTEA[])
`

func (q *Queries) GetOrderAllowedNodeIds(ctx context.Context, nonces [][]byte) ([]OrderAllowedNodeID, error) {
	rows, err := q.db.Query(ctx, getOrderAllowedNodeIds, nonces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderAllowedNodeID
	for rows.Next() {
		var i OrderAllowedNodeID
		if err := rows.Scan(&i.Nonce, &i.NodeKey, &i.Allowed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderAsk = `-- name: GetOrderAsk :one
SELECT nonce, channel_announcement_constraints, channel_confirmation_constraints 
FROM order_ask 
WHERE nonce=$1
`

func (q *Queries) GetOrderAsk(ctx context.Context, nonce []byte) (OrderAsk, error) {
	row := q.db.QueryRow(ctx, getOrderAsk, nonce)
	var i OrderAsk
	err := row.Scan(&i.Nonce, &i.ChannelAnnouncementConstraints, &i.ChannelConfirmationConstraints)
	return i, err
}

const getOrderBid = `-- name: GetOrderBid :one
SELECT nonce, min_node_tier, self_chan_balance, is_sidecar, unannounced_channel, zero_conf_channel 
FROM order_bid 
WHERE nonce=$1
`

func (q *Queries) GetOrderBid(ctx context.Context, nonce []byte) (OrderBid, error) {
	row := q.db.QueryRow(ctx, getOrderBid, nonce)
	var i OrderBid
	err := row.Scan(
		&i.Nonce,
		&i.MinNodeTier,
		&i.SelfChanBalance,
		&i.IsSidecar,
		&i.UnannouncedChannel,
		&i.ZeroConfChannel,
	)
	return i, err
}

const getOrderNetworkAddresses = `-- name: GetOrderNetworkAddresses :many
SELECT nonce, network, address 
FROM order_node_network_addresses
WHERE nonce = ANY($1::BYTEA[])
`

func (q *Queries) GetOrderNetworkAddresses(ctx context.Context, nonces [][]byte) ([]OrderNodeNetworkAddress, error) {
	rows, err := q.db.Query(ctx, getOrderNetworkAddresses, nonces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderNodeNetworkAddress
	for rows.Next() {
		var i OrderNodeNetworkAddress
		if err := rows.Scan(&i.Nonce, &i.Network, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderNonces = `-- name: GetOrderNonces :many
SELECT o.nonce
FROM orders o
WHERE archived = $1
ORDER BY nonce
LIMIT NULLIF($3::int, 0) OFFSET $2
`

type GetOrderNoncesParams struct {
	Archived    bool
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetOrderNonces(ctx context.Context, arg GetOrderNoncesParams) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getOrderNonces, arg.Archived, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var nonce []byte
		if err := rows.Scan(&nonce); err != nil {
			return nil, err
		}
		items = append(items, nonce)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderNoncesByTraderKey = `-- name: GetOrderNoncesByTraderKey :many
SELECT nonce, archived 
FROM orders o
WHERE trader_key = $1
ORDER BY nonce
LIMIT NULLIF($3::int, 0) OFFSET $2
`

type GetOrderNoncesByTraderKeyParams struct {
	TraderKey   []byte
	OffsetParam int32
	LimitParam  int32
}

type GetOrderNoncesByTraderKeyRow struct {
	Nonce    []byte
	Archived bool
}

func (q *Queries) GetOrderNoncesByTraderKey(ctx context.Context, arg GetOrderNoncesByTraderKeyParams) ([]GetOrderNoncesByTraderKeyRow, error) {
	rows, err := q.db.Query(ctx, getOrderNoncesByTraderKey, arg.TraderKey, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderNoncesByTraderKeyRow
	for rows.Next() {
		var i GetOrderNoncesByTraderKeyRow
		if err := rows.Scan(&i.Nonce, &i.Archived); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT o.nonce, type, trader_key, version, state, fixed_rate, amount, units, units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration, channel_type, signature, multisig_key, node_key, token_id, user_agent, archived, created_at, archived_at, ob.nonce, min_node_tier, self_chan_balance, is_sidecar, unannounced_channel, zero_conf_channel, oa.nonce, channel_announcement_constraints, channel_confirmation_constraints 
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
        LEFT JOIN order_ask oa ON o.nonce = oa.nonce
WHERE o.nonce = ANY($1::BYTEA[])
`

type GetOrdersRow struct {
	Nonce                          []byte
	Type                           int16
	TraderKey                      []byte
	Version                        int64
	State                          int16
	FixedRate                      int64
	Amount                         int64
	Units                          int64
	UnitsUnfulfilled               int64
	MinUnitsMatch                  int64
	MaxBatchFeeRate                int64
	LeaseDuration                  int64
	ChannelType                    int16
	Signature                      []byte
	MultisigKey                    []byte
	NodeKey                        []byte
	TokenID                        []byte
	UserAgent                      string
	Archived                       bool
	CreatedAt                      sql.NullTime
	ArchivedAt                     sql.NullTime
	Nonce_2                        []byte
	MinNodeTier                    sql.NullInt64
	SelfChanBalance                sql.NullInt64
	IsSidecar                      sql.NullBool
	UnannouncedChannel             sql.NullBool
	ZeroConfChannel                sql.NullBool
	Nonce_3                        []byte
	ChannelAnnouncementConstraints sql.NullInt16
	ChannelConfirmationConstraints sql.NullInt16
}

func (q *Queries) GetOrders(ctx context.Context, nonces [][]byte) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders, nonces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.Nonce,
			&i.Type,
			&i.TraderKey,
			&i.Version,
			&i.State,
			&i.FixedRate,
			&i.Amount,
			&i.Units,
			&i.UnitsUnfulfilled,
			&i.MinUnitsMatch,
			&i.MaxBatchFeeRate,
			&i.LeaseDuration,
			&i.ChannelType,
			&i.Signature,
			&i.MultisigKey,
			&i.NodeKey,
			&i.TokenID,
			&i.UserAgent,
			&i.Archived,
			&i.CreatedAt,
			&i.ArchivedAt,
			&i.Nonce_2,
			&i.MinNodeTier,
			&i.SelfChanBalance,
			&i.IsSidecar,
			&i.UnannouncedChannel,
			&i.ZeroConfChannel,
			&i.Nonce_3,
			&i.ChannelAnnouncementConstraints,
			&i.ChannelConfirmationConstraints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersCount = `-- name: GetOrdersCount :one
SELECT COUNT(*)
FROM orders
WHERE archived = $1
`

func (q *Queries) GetOrdersCount(ctx context.Context, archived bool) (int64, error) {
	row := q.db.QueryRow(ctx, getOrdersCount, archived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertOrder = `-- name: UpsertOrder :exec

INSERT INTO orders(
        nonce, type, trader_key, version, state, fixed_rate, amount, units,
        units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration,
        channel_type, signature, multisig_key, node_key, token_id, user_agent,
        archived, created_at, archived_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,
        $17, $18, $19, $20, $21)
ON CONFLICT (nonce)
DO UPDATE SET
        type=$2, trader_key=$3, version=$4, state=$5, fixed_rate=$6, amount=$7,
        units=$8, units_unfulfilled=$9, min_units_match=$10, 
        max_batch_fee_rate=$11, lease_duration=$12, channel_type=$13, 
        signature=$14, multisig_key=$15, node_key=$16, token_id=$17, 
        user_agent=$18, archived=$19, created_at=$20, archived_at=$21
`

type UpsertOrderParams struct {
	Nonce            []byte
	Type             int16
	TraderKey        []byte
	Version          int64
	State            int16
	FixedRate        int64
	Amount           int64
	Units            int64
	UnitsUnfulfilled int64
	MinUnitsMatch    int64
	MaxBatchFeeRate  int64
	LeaseDuration    int64
	ChannelType      int16
	Signature        []byte
	MultisigKey      []byte
	NodeKey          []byte
	TokenID          []byte
	UserAgent        string
	Archived         bool
	CreatedAt        sql.NullTime
	ArchivedAt       sql.NullTime
}

// - Order Queries ---
func (q *Queries) UpsertOrder(ctx context.Context, arg UpsertOrderParams) error {
	_, err := q.db.Exec(ctx, upsertOrder,
		arg.Nonce,
		arg.Type,
		arg.TraderKey,
		arg.Version,
		arg.State,
		arg.FixedRate,
		arg.Amount,
		arg.Units,
		arg.UnitsUnfulfilled,
		arg.MinUnitsMatch,
		arg.MaxBatchFeeRate,
		arg.LeaseDuration,
		arg.ChannelType,
		arg.Signature,
		arg.MultisigKey,
		arg.NodeKey,
		arg.TokenID,
		arg.UserAgent,
		arg.Archived,
		arg.CreatedAt,
		arg.ArchivedAt,
	)
	return err
}
