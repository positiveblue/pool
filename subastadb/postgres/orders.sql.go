// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: orders.sql

package postgres

import (
	"context"
	"database/sql"
)

type CreateOrderAllowedNodeIdsParams struct {
	Nonce   []byte
	NodeKey []byte
	Allowed bool
}

const createOrderBid = `-- name: CreateOrderBid :exec

INSERT INTO order_bid(
        nonce, min_node_tier, self_chan_balance, is_sidecar
) VALUES ($1, $2, $3, $4)
`

type CreateOrderBidParams struct {
	Nonce           []byte
	MinNodeTier     int64
	SelfChanBalance int64
	IsSidecar       bool
}

//- Order bid Queries ---
func (q *Queries) CreateOrderBid(ctx context.Context, arg CreateOrderBidParams) error {
	_, err := q.db.Exec(ctx, createOrderBid,
		arg.Nonce,
		arg.MinNodeTier,
		arg.SelfChanBalance,
		arg.IsSidecar,
	)
	return err
}

type CreateOrderNetworkAddressParams struct {
	Nonce   []byte
	Network string
	Address string
}

const deleteOrder = `-- name: DeleteOrder :execrows
DELETE 
FROM orders
WHERE nonce=$1
`

func (q *Queries) DeleteOrder(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrder, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderAllowedNodeIds = `-- name: DeleteOrderAllowedNodeIds :execrows
DELETE 
FROM order_allowed_node_ids
WHERE nonce = $1
`

func (q *Queries) DeleteOrderAllowedNodeIds(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderAllowedNodeIds, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderBid = `-- name: DeleteOrderBid :execrows
DELETE
FROM order_bid
WHERE nonce=$1
`

func (q *Queries) DeleteOrderBid(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderBid, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOrderNetworkAddresses = `-- name: DeleteOrderNetworkAddresses :execrows
DELETE 
FROM order_node_network_addresses
WHERE nonce=$1
`

func (q *Queries) DeleteOrderNetworkAddresses(ctx context.Context, nonce []byte) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOrderNetworkAddresses, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActiveOrderNonces = `-- name: GetActiveOrderNonces :many
SELECT o.nonce
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
WHERE archived = FALSE
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetActiveOrderNoncesParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetActiveOrderNonces(ctx context.Context, arg GetActiveOrderNoncesParams) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getActiveOrderNonces, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var nonce []byte
		if err := rows.Scan(&nonce); err != nil {
			return nil, err
		}
		items = append(items, nonce)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveOrdersCount = `-- name: GetActiveOrdersCount :one
SELECT COUNT(*)
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
WHERE archived = FALSE
`

func (q *Queries) GetActiveOrdersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getActiveOrdersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getArchivedOrderNonces = `-- name: GetArchivedOrderNonces :many
SELECT o.nonce
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
WHERE archived = TRUE
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetArchivedOrderNoncesParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetArchivedOrderNonces(ctx context.Context, arg GetArchivedOrderNoncesParams) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getArchivedOrderNonces, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var nonce []byte
		if err := rows.Scan(&nonce); err != nil {
			return nil, err
		}
		items = append(items, nonce)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArchivedOrdersCount = `-- name: GetArchivedOrdersCount :one
SELECT COUNT(*)
FROM orders
WHERE archived = TRUE
`

func (q *Queries) GetArchivedOrdersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getArchivedOrdersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOrder = `-- name: GetOrder :one
SELECT o.nonce, type, trader_key, version, state, fixed_rate, amount, units, units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration, channel_type, signature, multisig_key, node_key, token_id, user_agent, archived, ob.nonce, min_node_tier, self_chan_balance, is_sidecar 
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
WHERE o.nonce=$1
`

type GetOrderRow struct {
	Nonce            []byte
	Type             int16
	TraderKey        []byte
	Version          int64
	State            int16
	FixedRate        int64
	Amount           int64
	Units            int64
	UnitsUnfulfilled int64
	MinUnitsMatch    int64
	MaxBatchFeeRate  int64
	LeaseDuration    int64
	ChannelType      int16
	Signature        []byte
	MultisigKey      []byte
	NodeKey          []byte
	TokenID          []byte
	UserAgent        string
	Archived         bool
	Nonce_2          []byte
	MinNodeTier      sql.NullInt64
	SelfChanBalance  sql.NullInt64
	IsSidecar        sql.NullBool
}

func (q *Queries) GetOrder(ctx context.Context, nonce []byte) (GetOrderRow, error) {
	row := q.db.QueryRow(ctx, getOrder, nonce)
	var i GetOrderRow
	err := row.Scan(
		&i.Nonce,
		&i.Type,
		&i.TraderKey,
		&i.Version,
		&i.State,
		&i.FixedRate,
		&i.Amount,
		&i.Units,
		&i.UnitsUnfulfilled,
		&i.MinUnitsMatch,
		&i.MaxBatchFeeRate,
		&i.LeaseDuration,
		&i.ChannelType,
		&i.Signature,
		&i.MultisigKey,
		&i.NodeKey,
		&i.TokenID,
		&i.UserAgent,
		&i.Archived,
		&i.Nonce_2,
		&i.MinNodeTier,
		&i.SelfChanBalance,
		&i.IsSidecar,
	)
	return i, err
}

const getOrderAllowedNodeIds = `-- name: GetOrderAllowedNodeIds :many
SELECT nonce, node_key, allowed 
FROM order_allowed_node_ids 
WHERE nonce = $1
`

func (q *Queries) GetOrderAllowedNodeIds(ctx context.Context, nonce []byte) ([]OrderAllowedNodeID, error) {
	rows, err := q.db.Query(ctx, getOrderAllowedNodeIds, nonce)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderAllowedNodeID
	for rows.Next() {
		var i OrderAllowedNodeID
		if err := rows.Scan(&i.Nonce, &i.NodeKey, &i.Allowed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderBid = `-- name: GetOrderBid :one
SELECT nonce, min_node_tier, self_chan_balance, is_sidecar 
FROM order_bid 
WHERE nonce=$1
`

func (q *Queries) GetOrderBid(ctx context.Context, nonce []byte) (OrderBid, error) {
	row := q.db.QueryRow(ctx, getOrderBid, nonce)
	var i OrderBid
	err := row.Scan(
		&i.Nonce,
		&i.MinNodeTier,
		&i.SelfChanBalance,
		&i.IsSidecar,
	)
	return i, err
}

const getOrderNetworkAddresses = `-- name: GetOrderNetworkAddresses :many
SELECT nonce, network, address 
FROM order_node_network_addresses 
WHERE nonce=$1
`

func (q *Queries) GetOrderNetworkAddresses(ctx context.Context, nonce []byte) ([]OrderNodeNetworkAddress, error) {
	rows, err := q.db.Query(ctx, getOrderNetworkAddresses, nonce)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderNodeNetworkAddress
	for rows.Next() {
		var i OrderNodeNetworkAddress
		if err := rows.Scan(&i.Nonce, &i.Network, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderNonces = `-- name: GetOrderNonces :many
SELECT o.nonce
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetOrderNoncesParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetOrderNonces(ctx context.Context, arg GetOrderNoncesParams) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getOrderNonces, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var nonce []byte
		if err := rows.Scan(&nonce); err != nil {
			return nil, err
		}
		items = append(items, nonce)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT o.nonce, type, trader_key, version, state, fixed_rate, amount, units, units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration, channel_type, signature, multisig_key, node_key, token_id, user_agent, archived, ob.nonce, min_node_tier, self_chan_balance, is_sidecar 
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetOrdersParams struct {
	OffsetParam int32
	LimitParam  int32
}

type GetOrdersRow struct {
	Nonce            []byte
	Type             int16
	TraderKey        []byte
	Version          int64
	State            int16
	FixedRate        int64
	Amount           int64
	Units            int64
	UnitsUnfulfilled int64
	MinUnitsMatch    int64
	MaxBatchFeeRate  int64
	LeaseDuration    int64
	ChannelType      int16
	Signature        []byte
	MultisigKey      []byte
	NodeKey          []byte
	TokenID          []byte
	UserAgent        string
	Archived         bool
	Nonce_2          []byte
	MinNodeTier      sql.NullInt64
	SelfChanBalance  sql.NullInt64
	IsSidecar        sql.NullBool
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.Nonce,
			&i.Type,
			&i.TraderKey,
			&i.Version,
			&i.State,
			&i.FixedRate,
			&i.Amount,
			&i.Units,
			&i.UnitsUnfulfilled,
			&i.MinUnitsMatch,
			&i.MaxBatchFeeRate,
			&i.LeaseDuration,
			&i.ChannelType,
			&i.Signature,
			&i.MultisigKey,
			&i.NodeKey,
			&i.TokenID,
			&i.UserAgent,
			&i.Archived,
			&i.Nonce_2,
			&i.MinNodeTier,
			&i.SelfChanBalance,
			&i.IsSidecar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByNonces = `-- name: GetOrdersByNonces :many
SELECT o.nonce, type, trader_key, version, state, fixed_rate, amount, units, units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration, channel_type, signature, multisig_key, node_key, token_id, user_agent, archived, ob.nonce, min_node_tier, self_chan_balance, is_sidecar 
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
WHERE o.nonce = ANY($1::BYTEA[])
`

type GetOrdersByNoncesRow struct {
	Nonce            []byte
	Type             int16
	TraderKey        []byte
	Version          int64
	State            int16
	FixedRate        int64
	Amount           int64
	Units            int64
	UnitsUnfulfilled int64
	MinUnitsMatch    int64
	MaxBatchFeeRate  int64
	LeaseDuration    int64
	ChannelType      int16
	Signature        []byte
	MultisigKey      []byte
	NodeKey          []byte
	TokenID          []byte
	UserAgent        string
	Archived         bool
	Nonce_2          []byte
	MinNodeTier      sql.NullInt64
	SelfChanBalance  sql.NullInt64
	IsSidecar        sql.NullBool
}

func (q *Queries) GetOrdersByNonces(ctx context.Context, dollar_1 [][]byte) ([]GetOrdersByNoncesRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByNonces, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByNoncesRow
	for rows.Next() {
		var i GetOrdersByNoncesRow
		if err := rows.Scan(
			&i.Nonce,
			&i.Type,
			&i.TraderKey,
			&i.Version,
			&i.State,
			&i.FixedRate,
			&i.Amount,
			&i.Units,
			&i.UnitsUnfulfilled,
			&i.MinUnitsMatch,
			&i.MaxBatchFeeRate,
			&i.LeaseDuration,
			&i.ChannelType,
			&i.Signature,
			&i.MultisigKey,
			&i.NodeKey,
			&i.TokenID,
			&i.UserAgent,
			&i.Archived,
			&i.Nonce_2,
			&i.MinNodeTier,
			&i.SelfChanBalance,
			&i.IsSidecar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByTraderKey = `-- name: GetOrdersByTraderKey :many
SELECT o.nonce, type, trader_key, version, state, fixed_rate, amount, units, units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration, channel_type, signature, multisig_key, node_key, token_id, user_agent, archived, ob.nonce, min_node_tier, self_chan_balance, is_sidecar 
FROM orders o LEFT JOIN order_bid ob ON o.nonce = ob.nonce
WHERE trader_key = $1
LIMIT NULLIF($3::int, 0) OFFSET $2
`

type GetOrdersByTraderKeyParams struct {
	TraderKey   []byte
	OffsetParam int32
	LimitParam  int32
}

type GetOrdersByTraderKeyRow struct {
	Nonce            []byte
	Type             int16
	TraderKey        []byte
	Version          int64
	State            int16
	FixedRate        int64
	Amount           int64
	Units            int64
	UnitsUnfulfilled int64
	MinUnitsMatch    int64
	MaxBatchFeeRate  int64
	LeaseDuration    int64
	ChannelType      int16
	Signature        []byte
	MultisigKey      []byte
	NodeKey          []byte
	TokenID          []byte
	UserAgent        string
	Archived         bool
	Nonce_2          []byte
	MinNodeTier      sql.NullInt64
	SelfChanBalance  sql.NullInt64
	IsSidecar        sql.NullBool
}

func (q *Queries) GetOrdersByTraderKey(ctx context.Context, arg GetOrdersByTraderKeyParams) ([]GetOrdersByTraderKeyRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByTraderKey, arg.TraderKey, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersByTraderKeyRow
	for rows.Next() {
		var i GetOrdersByTraderKeyRow
		if err := rows.Scan(
			&i.Nonce,
			&i.Type,
			&i.TraderKey,
			&i.Version,
			&i.State,
			&i.FixedRate,
			&i.Amount,
			&i.Units,
			&i.UnitsUnfulfilled,
			&i.MinUnitsMatch,
			&i.MaxBatchFeeRate,
			&i.LeaseDuration,
			&i.ChannelType,
			&i.Signature,
			&i.MultisigKey,
			&i.NodeKey,
			&i.TokenID,
			&i.UserAgent,
			&i.Archived,
			&i.Nonce_2,
			&i.MinNodeTier,
			&i.SelfChanBalance,
			&i.IsSidecar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByTraderKeyCount = `-- name: GetOrdersByTraderKeyCount :one
SELECT COUNT(*)
FROM orders
WHERE trader_key = $1
`

func (q *Queries) GetOrdersByTraderKeyCount(ctx context.Context, traderKey []byte) (int64, error) {
	row := q.db.QueryRow(ctx, getOrdersByTraderKeyCount, traderKey)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertOrder = `-- name: UpsertOrder :exec

INSERT INTO orders(
        nonce, type, trader_key, version, state, fixed_rate, amount, units,
        units_unfulfilled, min_units_match, max_batch_fee_rate, lease_duration,
        channel_type, signature, multisig_key, node_key, token_id, user_agent,
        archived) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,
        $17, $18, $19)
ON CONFLICT (nonce)
DO UPDATE SET
        type=$2, trader_key=$3, version=$4, state=$5, fixed_rate=$6, amount=$7,
        units=$8, units_unfulfilled=$9, min_units_match=$10, 
        max_batch_fee_rate=$11, lease_duration=$12, channel_type=$13, 
        signature=$14, multisig_key=$15, node_key=$16, token_id=$17, 
        user_agent=$18, archived=$19
`

type UpsertOrderParams struct {
	Nonce            []byte
	Type             int16
	TraderKey        []byte
	Version          int64
	State            int16
	FixedRate        int64
	Amount           int64
	Units            int64
	UnitsUnfulfilled int64
	MinUnitsMatch    int64
	MaxBatchFeeRate  int64
	LeaseDuration    int64
	ChannelType      int16
	Signature        []byte
	MultisigKey      []byte
	NodeKey          []byte
	TokenID          []byte
	UserAgent        string
	Archived         bool
}

//- Order Queries ---
func (q *Queries) UpsertOrder(ctx context.Context, arg UpsertOrderParams) error {
	_, err := q.db.Exec(ctx, upsertOrder,
		arg.Nonce,
		arg.Type,
		arg.TraderKey,
		arg.Version,
		arg.State,
		arg.FixedRate,
		arg.Amount,
		arg.Units,
		arg.UnitsUnfulfilled,
		arg.MinUnitsMatch,
		arg.MaxBatchFeeRate,
		arg.LeaseDuration,
		arg.ChannelType,
		arg.Signature,
		arg.MultisigKey,
		arg.NodeKey,
		arg.TokenID,
		arg.UserAgent,
		arg.Archived,
	)
	return err
}
