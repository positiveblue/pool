// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: batches.sql

package postgres

import (
	"context"
	"database/sql"
)

const confirmBatch = `-- name: ConfirmBatch :execrows
UPDATE batches
SET confirmed=TRUE
WHERE batch_key = $1
`

func (q *Queries) ConfirmBatch(ctx context.Context, batchKey []byte) (int64, error) {
	result, err := q.db.Exec(ctx, confirmBatch, batchKey)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

type CreateBatchAccountDiffParams struct {
	BatchKey               []byte
	TraderKey              []byte
	TraderBatchKey         []byte
	TraderNextBatchKey     []byte
	Secret                 []byte
	TotalExecutionFeesPaid int64
	TotalTakerFeesPaid     int64
	TotalMakerFeesAccrued  int64
	NumChansCreated        int64
	StartingBalance        int64
	StartingAccountExpiry  int64
	StartingOutPointHash   []byte
	StartingOutPointIndex  int64
	EndingBalance          int64
	NewAccountExpiry       int64
	TxOutValue             sql.NullInt64
	TxOutPkscript          []byte
}

type CreateClearingPriceParams struct {
	BatchKey         []byte
	LeaseDuration    int64
	FixedRatePremium int64
}

type CreateMatchedOrderParams struct {
	BatchKey          []byte
	AskOrderNonce     []byte
	BidOrderNonce     []byte
	LeaseDuration     int64
	MatchingRate      int64
	TotalSatsCleared  int64
	UnitsMatched      int64
	UnitsUnmatched    int64
	AskUnitsUnmatched int64
	BidUnitsUnmatched int64
	FulfillType       int16
	AskState          int16
	BidState          int16
	AskerExpiry       int64
	BidderExpiry      int64
}

const getAllMatchedOrdersByBatchID = `-- name: GetAllMatchedOrdersByBatchID :many
SELECT batch_key, ask_order_nonce, bid_order_nonce, lease_duration, matching_rate, total_sats_cleared, units_matched, units_unmatched, fulfill_type, ask_units_unmatched, bid_units_unmatched, ask_state, bid_state, asker_expiry, bidder_expiry 
FROM batch_matched_orders
WHERE batch_key=$1
`

func (q *Queries) GetAllMatchedOrdersByBatchID(ctx context.Context, batchKey []byte) ([]BatchMatchedOrder, error) {
	rows, err := q.db.Query(ctx, getAllMatchedOrdersByBatchID, batchKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchMatchedOrder
	for rows.Next() {
		var i BatchMatchedOrder
		if err := rows.Scan(
			&i.BatchKey,
			&i.AskOrderNonce,
			&i.BidOrderNonce,
			&i.LeaseDuration,
			&i.MatchingRate,
			&i.TotalSatsCleared,
			&i.UnitsMatched,
			&i.UnitsUnmatched,
			&i.FulfillType,
			&i.AskUnitsUnmatched,
			&i.BidUnitsUnmatched,
			&i.AskState,
			&i.BidState,
			&i.AskerExpiry,
			&i.BidderExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatch = `-- name: GetBatch :one
SELECT batch_key, batch_tx, batch_tx_fee, version, auctioneer_fees_accrued, confirmed, created_at 
FROM batches 
WHERE batch_key = $1
`

func (q *Queries) GetBatch(ctx context.Context, batchKey []byte) (Batch, error) {
	row := q.db.QueryRow(ctx, getBatch, batchKey)
	var i Batch
	err := row.Scan(
		&i.BatchKey,
		&i.BatchTx,
		&i.BatchTxFee,
		&i.Version,
		&i.AuctioneerFeesAccrued,
		&i.Confirmed,
		&i.CreatedAt,
	)
	return i, err
}

const getBatchAccountDiffs = `-- name: GetBatchAccountDiffs :many
SELECT batch_key, trader_key, trader_batch_key, trader_next_batch_key, secret, total_execution_fees_paid, total_taker_fees_paid, total_maker_fees_accrued, num_chans_created, starting_balance, starting_account_expiry, starting_out_point_hash, starting_out_point_index, ending_balance, new_account_expiry, tx_out_value, tx_out_pkscript
FROM batch_account_diffs
WHERE batch_key=$1
`

func (q *Queries) GetBatchAccountDiffs(ctx context.Context, batchKey []byte) ([]BatchAccountDiff, error) {
	rows, err := q.db.Query(ctx, getBatchAccountDiffs, batchKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchAccountDiff
	for rows.Next() {
		var i BatchAccountDiff
		if err := rows.Scan(
			&i.BatchKey,
			&i.TraderKey,
			&i.TraderBatchKey,
			&i.TraderNextBatchKey,
			&i.Secret,
			&i.TotalExecutionFeesPaid,
			&i.TotalTakerFeesPaid,
			&i.TotalMakerFeesAccrued,
			&i.NumChansCreated,
			&i.StartingBalance,
			&i.StartingAccountExpiry,
			&i.StartingOutPointHash,
			&i.StartingOutPointIndex,
			&i.EndingBalance,
			&i.NewAccountExpiry,
			&i.TxOutValue,
			&i.TxOutPkscript,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchAccountDiffsMatchingBatchIDs = `-- name: GetBatchAccountDiffsMatchingBatchIDs :many
SELECT batch_key, trader_key, trader_batch_key, trader_next_batch_key, secret, total_execution_fees_paid, total_taker_fees_paid, total_maker_fees_accrued, num_chans_created, starting_balance, starting_account_expiry, starting_out_point_hash, starting_out_point_index, ending_balance, new_account_expiry, tx_out_value, tx_out_pkscript 
FROM batch_account_diffs
WHERE batch_key = ANY($1::BYTEA[])
`

func (q *Queries) GetBatchAccountDiffsMatchingBatchIDs(ctx context.Context, dollar_1 [][]byte) ([]BatchAccountDiff, error) {
	rows, err := q.db.Query(ctx, getBatchAccountDiffsMatchingBatchIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchAccountDiff
	for rows.Next() {
		var i BatchAccountDiff
		if err := rows.Scan(
			&i.BatchKey,
			&i.TraderKey,
			&i.TraderBatchKey,
			&i.TraderNextBatchKey,
			&i.Secret,
			&i.TotalExecutionFeesPaid,
			&i.TotalTakerFeesPaid,
			&i.TotalMakerFeesAccrued,
			&i.NumChansCreated,
			&i.StartingBalance,
			&i.StartingAccountExpiry,
			&i.StartingOutPointHash,
			&i.StartingOutPointIndex,
			&i.EndingBalance,
			&i.NewAccountExpiry,
			&i.TxOutValue,
			&i.TxOutPkscript,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchClearingPrices = `-- name: GetBatchClearingPrices :many
SELECT batch_key, lease_duration, fixed_rate_premium 
FROM batch_clearing_prices 
WHERE batch_key=$1
`

func (q *Queries) GetBatchClearingPrices(ctx context.Context, batchKey []byte) ([]BatchClearingPrice, error) {
	rows, err := q.db.Query(ctx, getBatchClearingPrices, batchKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchClearingPrice
	for rows.Next() {
		var i BatchClearingPrice
		if err := rows.Scan(&i.BatchKey, &i.LeaseDuration, &i.FixedRatePremium); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchClearingPricesMatchingBatchIDs = `-- name: GetBatchClearingPricesMatchingBatchIDs :many
SELECT batch_key, lease_duration, fixed_rate_premium 
FROM batch_clearing_prices
WHERE batch_key = ANY($1::BYTEA[])
`

func (q *Queries) GetBatchClearingPricesMatchingBatchIDs(ctx context.Context, dollar_1 [][]byte) ([]BatchClearingPrice, error) {
	rows, err := q.db.Query(ctx, getBatchClearingPricesMatchingBatchIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchClearingPrice
	for rows.Next() {
		var i BatchClearingPrice
		if err := rows.Scan(&i.BatchKey, &i.LeaseDuration, &i.FixedRatePremium); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchKeys = `-- name: GetBatchKeys :many
SELECT batch_key 
FROM batches 
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetBatchKeysParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetBatchKeys(ctx context.Context, arg GetBatchKeysParams) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getBatchKeys, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var batch_key []byte
		if err := rows.Scan(&batch_key); err != nil {
			return nil, err
		}
		items = append(items, batch_key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatches = `-- name: GetBatches :many
SELECT batch_key, batch_tx, batch_tx_fee, version, auctioneer_fees_accrued, confirmed, created_at
FROM batches
LIMIT $1 OFFSET $2
`

type GetBatchesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetBatches(ctx context.Context, arg GetBatchesParams) ([]Batch, error) {
	rows, err := q.db.Query(ctx, getBatches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Batch
	for rows.Next() {
		var i Batch
		if err := rows.Scan(
			&i.BatchKey,
			&i.BatchTx,
			&i.BatchTxFee,
			&i.Version,
			&i.AuctioneerFeesAccrued,
			&i.Confirmed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBatchesCount = `-- name: GetBatchesCount :one
SELECT COUNT(*)
FROM batches
`

func (q *Queries) GetBatchesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getBatchesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCurrentBatchKey = `-- name: GetCurrentBatchKey :one

SELECT id, batch_key, updated_at
FROM current_batch_key
`

//- Current Batch key queries ---
func (q *Queries) GetCurrentBatchKey(ctx context.Context) (CurrentBatchKey, error) {
	row := q.db.QueryRow(ctx, getCurrentBatchKey)
	var i CurrentBatchKey
	err := row.Scan(&i.ID, &i.BatchKey, &i.UpdatedAt)
	return i, err
}

const getMatchedOrders = `-- name: GetMatchedOrders :many
SELECT batch_key, ask_order_nonce, bid_order_nonce, lease_duration, matching_rate, total_sats_cleared, units_matched, units_unmatched, fulfill_type, ask_units_unmatched, bid_units_unmatched, ask_state, bid_state, asker_expiry, bidder_expiry 
FROM batch_matched_orders
LIMIT NULLIF($2::int, 0) OFFSET $1
`

type GetMatchedOrdersParams struct {
	OffsetParam int32
	LimitParam  int32
}

func (q *Queries) GetMatchedOrders(ctx context.Context, arg GetMatchedOrdersParams) ([]BatchMatchedOrder, error) {
	rows, err := q.db.Query(ctx, getMatchedOrders, arg.OffsetParam, arg.LimitParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchMatchedOrder
	for rows.Next() {
		var i BatchMatchedOrder
		if err := rows.Scan(
			&i.BatchKey,
			&i.AskOrderNonce,
			&i.BidOrderNonce,
			&i.LeaseDuration,
			&i.MatchingRate,
			&i.TotalSatsCleared,
			&i.UnitsMatched,
			&i.UnitsUnmatched,
			&i.FulfillType,
			&i.AskUnitsUnmatched,
			&i.BidUnitsUnmatched,
			&i.AskState,
			&i.BidState,
			&i.AskerExpiry,
			&i.BidderExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchedOrdersCount = `-- name: GetMatchedOrdersCount :one
SELECT COUNT(*)
FROM batch_matched_orders
`

func (q *Queries) GetMatchedOrdersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getMatchedOrdersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isBatchConfirmed = `-- name: IsBatchConfirmed :one
SELECT confirmed
FROM batches
WHERE batch_key = $1
`

func (q *Queries) IsBatchConfirmed(ctx context.Context, batchKey []byte) (bool, error) {
	row := q.db.QueryRow(ctx, isBatchConfirmed, batchKey)
	var confirmed bool
	err := row.Scan(&confirmed)
	return confirmed, err
}

const upsertBatch = `-- name: UpsertBatch :exec

INSERT INTO batches(
        batch_key, batch_tx, batch_tx_fee, version, auctioneer_fees_accrued,
        confirmed, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (batch_key)
DO UPDATE SET
        batch_tx=$2, batch_tx_fee=$3, version=$4, auctioneer_fees_accrued=$5
`

type UpsertBatchParams struct {
	BatchKey              []byte
	BatchTx               []byte
	BatchTxFee            int64
	Version               int64
	AuctioneerFeesAccrued int64
	Confirmed             bool
	CreatedAt             sql.NullTime
}

//- Batch Queries ---
func (q *Queries) UpsertBatch(ctx context.Context, arg UpsertBatchParams) error {
	_, err := q.db.Exec(ctx, upsertBatch,
		arg.BatchKey,
		arg.BatchTx,
		arg.BatchTxFee,
		arg.Version,
		arg.AuctioneerFeesAccrued,
		arg.Confirmed,
		arg.CreatedAt,
	)
	return err
}

const upsertCurrentBatchKey = `-- name: UpsertCurrentBatchKey :exec
INSERT INTO current_batch_key(id, batch_key, updated_at)
VALUES ($1, $2, CURRENT_TIMESTAMP)
ON CONFLICT (id)
DO UPDATE SET batch_key=$2, updated_at=CURRENT_TIMESTAMP
`

type UpsertCurrentBatchKeyParams struct {
	ID       int64
	BatchKey []byte
}

func (q *Queries) UpsertCurrentBatchKey(ctx context.Context, arg UpsertCurrentBatchKeyParams) error {
	_, err := q.db.Exec(ctx, upsertCurrentBatchKey, arg.ID, arg.BatchKey)
	return err
}
