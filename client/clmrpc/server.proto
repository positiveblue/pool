syntax = "proto3";

import "google/api/annotations.proto";

package clmrpc;

service ChannelAuctioneerServer {
    rpc ReserveAccount (ReserveAccountRequest) returns (ReserveAccountResponse);
    rpc InitAccount (ServerInitAccountRequest) returns (ServerInitAccountResponse);
    rpc CloseAccount (ServerCloseAccountRequest) returns (ServerCloseAccountResponse);
    rpc ModifyAccount (ServerModifyAccountRequest) returns (ServerModifyAccountResponse);
    rpc SubmitOrder (ServerOrderRequest) returns (ServerOrderResponse);
    rpc CancelOrder (ServerOrderRequest) returns (ServerOrderResponse);
    rpc SubscribeBatchAuction (stream ClientAuctionMessage) returns (stream ServerAuctionMessage);
}

message ReserveAccountRequest {
    bytes user_sub_key = 1;
}
message ReserveAccountResponse {
    bytes auctioneer_key = 1;
}

message ServerInitAccountRequest {
    /**
    Transaction output of the account. Has to be unspent and be a P2WSH of
    the account script below. The amount must also exactly correspond to the
    account value below.
    */
    OutPoint account_point = 1;

    /**
    The script used to create the account point.
    */
    bytes account_script = 2;

    /**
    The value of the account in satoshis. Must match the amount of the
    account_point output.
    */
    uint32 account_value = 3;

    /**
    The block height at which the account should expire.
    */
    uint32 account_expiry = 4;

    /**
    The user's sub account key.
    */
    bytes user_sub_key = 5;
}
message ServerInitAccountResponse {}

message ServerCloseAccountRequest {
    /**
    The user's sub account key.
    */
    bytes user_sub_key = 1;

    /**
    Specifies where the money from the account should be sent to.
    */
    map<int64, bytes> close_outputs = 2;
}
message ServerCloseAccountResponse {
    /**
    Signature that allows the user to broadcast their account closing
    transaction.
    */
    bytes close_sig = 1;
}

message ServerOrderRequest {
    oneof details {
        /**
        Submit an ask order.
        */
        ServerAsk ask = 1;
        
        /**
        Submit a bid order.
        */
        ServerBid bid = 2;
    }
}
message ServerOrderResponse {
    oneof details {
        /**
        Order failed with the given reason.
        */
        InvalidOrder invalid_order = 1;
        
        /**
        Order was accepted.
        */
        bool accepted = 2;
    }
}

message ClientAuctionMessage {
    oneof msg {
        OrderMatchPrepare prepare = 1;
        OrderMatchAccept accept = 2;
        OrderMatchSign sign = 3;
        OrderMatchFinalize finalize = 4;
    }
}

message OrderMatchPrepare {}
message OrderMatchAccept {}
message OrderMatchSign {}
message OrderMatchFinalize {}
message ServerAuctionMessage {}

message ServerBid {
    /**
    Fixed order rate in parts per million.
    */
    int64 rate_fixed = 1;
    
    /**
    Order amount in satoshis.
    */
    int64 amt = 2;
    
    /**
    Required minimum channel duration in blocks.
    */
    int64 min_duration_blocks = 3;

    // TODO(guggero): implement
    // bool instant = 4;
    // bool kill_or_fill = 5;
    // repeated bytes must_fill_pub = 6;
    reserved 4, 5, 6;

    /**
    Order nonce, acts as unique order identifier.
    */
    bytes order_nonce = 7;

    /**
    Signature for the order.
    */
    bytes order_sig = 8;

    bytes multi_sig_key = 9;
    bytes node_pub = 10;
    NodeAddress node_addr = 11;

    /*
    // TODO(guggero): implement 
    int64 min_node_score = 12;
    */
    reserved 12;
    
    uint32 chan_type = 13;
    int64 funding_fee_rate = 14;
}

message ServerAsk {
    /**
    Fixed order rate in parts per million.
    */
    int64 rate_fixed = 1;

    /**
    Order amount in satoshis.
    */
    int64 amt = 2;

    /**
    Required minimum channel duration in blocks.
    */
    int64 max_duration_blocks = 3;
    
    /**
    // TODO(guggero): implement
    bool kill_or_fill = 4;
    repeated bytes must_fill_pub = 6;
    */
    reserved 4, 5, 6;

    /**
    Order nonce, acts as unique order identifier.
    */
    bytes order_nonce = 7;
    
    /**
    Signature for the order.
    */
    bytes order_sig = 8;

    bytes multi_sig_key = 9;
    bytes node_pub = 10;
    NodeAddress node_addr = 11;

    /*
    // TODO(guggero): implement 
    int64 min_node_score = 12;
    */
    reserved 12;
    
    uint32 chan_type = 13;
    int64 funding_fee_rate = 14;
}

message CancelOrder {
    bytes order_nonce = 1;
}

message InvalidOrder {

    enum FailReason {
        INVALID_AMT = 0;
    }

    bytes order_nonce = 1;
    FailReason fail_reason = 2;
    string fail_string = 3;
}

message Input {
    OutPoint outpoint = 1;
    int64 input_value = 2;
}

message ServerModifyAccountRequest {
    OutPoint account_point = 1;

    Input new_inputs = 2;
    map<int64, bytes> outputs = 3;

    int64 new_account_balance = 4;

    ServerInitAccountRequest new_account = 5;
}

message ServerModifyAccountResponse {
    bytes new_account_sig = 1;
    OutPoint new_account_point = 2;
}

message NodeAddress {
    string network = 1;
    string addr = 2;
}

message OutPoint {
    /**
    Raw bytes representing the transaction id.
    */
    bytes txid = 1 [json_name = "txid"];

    /**
    The index of the output on the transaction.
    */
    uint32 output_index = 2 [json_name = "output_index"];
}
