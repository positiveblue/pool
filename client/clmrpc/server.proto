syntax = "proto3";

import "google/api/annotations.proto";

package clmrpc;

service ChannelAuctioneerServer {
    rpc ReserveAccount (ReserveAccountRequest) returns (ReserveAccountResponse);
    rpc InitAccount (ServerInitAccountRequest) returns (ServerInitAccountResponse);
    rpc ModifyAccount (ServerModifyAccountRequest) returns (ServerModifyAccountResponse);
    rpc SubmitOrder (ServerSubmitOrderRequest) returns (ServerSubmitOrderResponse);
    rpc CancelOrder (ServerCancelOrderRequest) returns (ServerCancelOrderResponse);
    rpc OrderState (ServerOrderStateRequest) returns (ServerOrderStateResponse);
    rpc SubscribeBatchAuction (stream ClientAuctionMessage) returns (stream ServerAuctionMessage);
}

message ReserveAccountRequest {
}
message ReserveAccountResponse {
    /*
    The base key of the auctioneer. This key should be tweaked with the trader's
    per-batch tweaked key to obtain the corresponding per-batch tweaked
    auctioneer key.
    */
    bytes auctioneer_key = 1;

    /*
    The initial per-batch key to be used for the account. For every cleared
    batch that the account participates in, this key will be incremented by the
    base point of its curve, resulting in a new key for both the trader and
    auctioneer in every batch.
    */
    bytes initial_batch_key = 2;
}

message ServerInitAccountRequest {
    /**
    Transaction output of the account. Has to be unspent and be a P2WSH of
    the account script below. The amount must also exactly correspond to the
    account value below.
    */
    OutPoint account_point = 1;

    /**
    The script used to create the account point.
    */
    bytes account_script = 2;

    /**
    The value of the account in satoshis. Must match the amount of the
    account_point output.
    */
    uint32 account_value = 3;

    /**
    The block height at which the account should expire.
    */
    uint32 account_expiry = 4;

    /**
    The user's sub account key.
    */
    bytes user_sub_key = 5;
}
message ServerInitAccountResponse {
}

message ServerSubmitOrderRequest {
    oneof details {
        /**
        Submit an ask order.
        */
        ServerAsk ask = 1;

        /**
        Submit a bid order.
        */
        ServerBid bid = 2;
    }
}
message ServerSubmitOrderResponse {
    oneof details {
        /**
        Order failed with the given reason.
        */
        InvalidOrder invalid_order = 1;

        /**
        Order was accepted.
        */
        bool accepted = 2;
    }
}

message ServerCancelOrderRequest {
    /**
    The order's unique identifier.
    */
    bytes order_nonce = 1;
}
message ServerCancelOrderResponse {
}

message ClientAuctionMessage {
    oneof msg {
        OrderMatchPrepare prepare = 1;
        OrderMatchAccept accept = 2;
        OrderMatchSign sign = 3;
        OrderMatchFinalize finalize = 4;
    }
}

message OrderMatchPrepare {
}
message OrderMatchAccept {
}
message OrderMatchSign {
}
message OrderMatchFinalize {
}
message ServerAuctionMessage {
}

message ServerOrder {
    /**
    The user's sub key of the account to use for the order.
    */
    bytes user_sub_key = 1;

    /**
    Fixed order rate in parts per million.
    */
    int64 rate_fixed = 2;

    /**
    Order amount in satoshis.
    */
    int64 amt = 3;

    // TODO(guggero): implement
    // bool kill_or_fill = 4;
    // repeated bytes must_fill_pub = 5;
    reserved 4, 5;

    /**
    Order nonce, acts as unique order identifier.
    */
    bytes order_nonce = 6;

    /**
    Signature of the order's digest, signed with the user's account key. The
    signature must be fixed-size LN wire format encoded. Version 0 includes the
    fields version, rate_fixed, amt, funding_fee_rate and
    min/max_duration_blocks in the order digest.
    */
    bytes order_sig = 7;

    /**
    The multi signature key of the node creating the order, will be used for the
    target channel's funding TX 2-of-2 multi signature output. 
    */
    bytes multi_sig_key = 8;

    /**
    The pubkey of the node creating the order.
    */
    bytes node_pub = 9;

    /**
    The network addresses of the node creating the order.
    */
    repeated NodeAddress node_addr = 10;

    /*
    // TODO(guggero): implement 
    int64 min_node_score = 11;
    */
    reserved 11;

    /**
    The type of the channel that should be opened.
    */
    uint32 chan_type = 12;

    /**
    Preferred fee rate to be used for the channel funding transaction, expressed
    in satoshis per 1000 weight units (sat/kW).
    */
    int64 funding_fee_rate = 13;
}

message ServerBid {
    /**
    The common fields shared between both ask and bid order types.
    */
    ServerOrder details = 1;

    /**
    Required minimum number of blocks that a channel opened as a result of this
    bid should be kept open.
    */
    int64 min_duration_blocks = 2;

    // TODO(guggero): implement
    // bool instant = 3;
    reserved 3;

    /**
    The version of the order format that is used. Will be increased once new
    features are added.
    */
    uint32 version = 4;
}

message ServerAsk {
    /**
    The common fields shared between both ask and bid order types.
    */
    ServerOrder details = 1;

    /**
    The maximum number of blocks the liquidity provider is willing to provide
    the channel funds for.
    */
    int64 max_duration_blocks = 4;

    /**
    The version of the order format that is used. Will be increased once new
    features are added.
    */
    uint32 version = 5;
}

message CancelOrder {
    bytes order_nonce = 1;
}

message InvalidOrder {

    enum FailReason {
        INVALID_AMT = 0;
    }

    bytes order_nonce = 1;
    FailReason fail_reason = 2;
    string fail_string = 3;
}

message Input {
    // The outpoint that the input corresponds to.
    OutPoint outpoint = 1;
}

message Output {
    // The value, in satoshis, of the output.
    uint32 value = 1 [json_name = "value"];

    // The script of the output to send the value to.
    bytes script = 2 [json_name = "script"];
}

message ServerModifyAccountRequest {
    /*
    The user sub key that corresponds to the account to be modified. This is
    also known as the trader key.
    */
    bytes user_sub_key = 1;

    /*
    An additional set of inputs that can be included in the spending transaction
    of an account. These can be used to deposit more funds into an account.
    These must be under control of the backing lnd node's wallet.
    */
    repeated Input new_inputs = 2;

    /*
    An additional set of outputs that can be included in the spending
    transaction of an account. These can be used to withdraw funds from an
    account.
    */
    repeated Output new_outputs = 3;

    // The new parameters to apply for the account.
    ServerInitAccountRequest new_account = 5;
}

message ServerModifyAccountResponse {
    /**
    The auctioneer's signature that allows a trader to broadcast a transaction
    spending from an account output.
    */
    bytes account_sig = 1;
}

message ServerOrderStateRequest {
    bytes order_nonce = 1;
}

message ServerOrderStateResponse {
    enum OrderState {
        SUBMITTED = 0;
        CLEARED = 1;
        PARTIAL_FILL = 2;
        EXECUTED = 3;
        CANCELED = 4;
        EXPIRED = 5;
        FAILED = 6;
    }

    /**
    The state the order currently is in.
    */
    OrderState state = 1;

    /**
    The number of currently unfilled units of this order. This will be equal to
    the total amount of units until the order has reached the state PARTIAL_FILL
    or EXECUTED.
    */
    uint32 units_unfulfilled = 2;
}

message NodeAddress {
    string network = 1;
    string addr = 2;
}

message OutPoint {
    /**
    Raw bytes representing the transaction id.
    */
    bytes txid = 1 [json_name = "txid"];

    /**
    The index of the output on the transaction.
    */
    uint32 output_index = 2 [json_name = "output_index"];
}
