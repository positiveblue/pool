package agora

import (
	"crypto/tls"
	"errors"
	"fmt"
	"net"
	"net/http"
	"path/filepath"

	"github.com/btcsuite/btcutil"
	"github.com/lightninglabs/agora/agoradb"
	"github.com/lightninglabs/agora/client/clmrpc"
	"github.com/lightninglabs/kirin/auth"
	"github.com/lightninglabs/loop/lndclient"
	"github.com/lightningnetwork/lnd/build"
	"github.com/lightningnetwork/lnd/cert"
	"github.com/lightningnetwork/lnd/lnrpc"
	"golang.org/x/crypto/acme/autocert"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
)

// Server is the main agora auctioneer server.
type Server struct {
	auctioneerServer *rpcServer
}

// NewServer returns a new auctioneer server that is started in daemon mode,
// listens for gRPC connections and executes commands.
func NewServer(cfg *Config) (*Server, error) {
	// Append the network type to the log directory so it is
	// "namespaced" per network in the same fashion as the data directory.
	logDir := filepath.Join(cfg.LogDir, cfg.Network)

	// Initialize logging at the default logging level.
	err := logWriter.InitLogRotator(
		filepath.Join(logDir, defaultLogFilename),
		cfg.MaxLogFileSize, cfg.MaxLogFiles,
	)
	if err != nil {
		return nil, err
	}
	err = build.ParseAndSetDebugLevels(cfg.DebugLevel, logWriter)
	if err != nil {
		return nil, err
	}

	lndServices, err := lndclient.NewLndServices(
		cfg.Lnd.Host, cfg.Network, cfg.Lnd.MacaroonDir,
		cfg.Lnd.TLSPath,
	)
	if err != nil {
		return nil, err
	}

	store, err := agoradb.NewEtcdStore(
		*lndServices.ChainParams, cfg.Etcd.Host, cfg.Etcd.User,
		cfg.Etcd.Password,
	)
	if err != nil {
		return nil, err
	}

	interceptor := auth.ServerInterceptor{}
	serverOpts := []grpc.ServerOption{
		grpc.UnaryInterceptor(interceptor.UnaryInterceptor),
		grpc.StreamInterceptor(interceptor.StreamInterceptor),
	}
	switch {
	// If auto cert is configured, then we'll create a cert automatically
	// using Let's Encrypt.
	case !cfg.Insecure && cfg.AutoCert:
		serverName := cfg.ServerName
		if serverName == "" {
			return nil, errors.New("servername option is required " +
				"for secure operation")
		}

		certDir := filepath.Join(cfg.BaseDir, "autocert")
		log.Infof("Configuring autocert for server %v and cache dir %v",
			serverName, certDir)

		manager := autocert.Manager{
			Cache:      autocert.DirCache(certDir),
			Prompt:     autocert.AcceptTOS,
			HostPolicy: autocert.HostWhitelist(serverName),
		}

		go func() {
			err := http.ListenAndServe(
				":http", manager.HTTPHandler(nil),
			)
			if err != nil {
				log.Errorf("autocert http: %v", err)
			}
		}()
		tlsConf := &tls.Config{
			GetCertificate: manager.GetCertificate,
		}

		sCreds := credentials.NewTLS(tlsConf)
		serverOpts = append(serverOpts, grpc.Creds(sCreds))

	// Otherwise, we'll generate custom self-signed cets.
	case !cfg.Insecure:
		// Ensure we create TLS key and certificate if they don't exist
		if !lnrpc.FileExists(cfg.TLSCertPath) &&
			!lnrpc.FileExists(cfg.TLSKeyPath) {

			err := cert.GenCertPair(
				"agora autogenerated cert", cfg.TLSCertPath,
				cfg.TLSKeyPath, nil, nil,
				cert.DefaultAutogenValidity,
			)
			if err != nil {
				return nil, err
			}
		}
		certData, _, err := cert.LoadCert(
			cfg.TLSCertPath, cfg.TLSKeyPath,
		)
		if err != nil {
			return nil, err
		}
		sCreds := credentials.NewTLS(cert.TLSConfFromCert(certData))
		serverOpts = append(serverOpts, grpc.Creds(sCreds))
	}

	// Start the gRPC server listening for HTTP/2 connections.
	log.Infof("Starting gRPC listener")
	grpcListener := cfg.RPCListener
	if grpcListener == nil {
		grpcListener, err = net.Listen("tcp", defaultAuctioneerAddr)
		if err != nil {
			return nil, fmt.Errorf("RPC server unable to listen "+
				"on %s", defaultAuctioneerAddr)
		}
	}

	auctioneerServer, err := newRPCServer(
		lndServices, store, grpcListener, serverOpts,
		btcutil.Amount(cfg.OrderSubmitFee),
	)
	if err != nil {
		return nil, err
	}

	clmrpc.RegisterChannelAuctioneerServer(
		auctioneerServer.Server, auctioneerServer,
	)

	// Start the auctioneer server itself.
	err = auctioneerServer.Start()
	if err != nil {
		return nil, fmt.Errorf("unable to start agora server: %v", err)
	}
	return &Server{
		auctioneerServer: auctioneerServer,
	}, nil
}

// Stop shuts down the server, including all client connections and network
// listeners.
func (s *Server) Stop() error {
	log.Info("Received shutdown signal, stopping server")
	err := s.auctioneerServer.Stop()
	if err != nil {
		return fmt.Errorf("error shutting down server: %v", err)
	}
	return nil
}
