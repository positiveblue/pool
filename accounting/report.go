package accounting

import (
	"context"
	"fmt"
	"time"

	"github.com/btcsuite/btcd/btcutil"
	"github.com/lightninglabs/faraday/fiat"
	"github.com/lightningnetwork/lnd/lnwire"
	"github.com/shopspring/decimal"
)

// Summary contains the most relevant information of the report.
type Summary struct {
	// CreatioTime is the timestamp of when our report was created.
	CreationTime time.Time

	// Start is the time from which our report will be created, inclusive.
	Start time.Time

	// End is the time until which our report will be created, exclusive.
	End time.Time

	// ClosingBalance is the full balance of the auctioneer at CreationTime.
	ClosingBalance btcutil.Amount

	// ClosingBalanceInUSD is the full balance of the auctioneer at
	// CreationTime in USD.
	ClosingBalanceInUSD decimal.Decimal

	//
	// Gross Revenue (does not discount operational costs)
	//

	// LeaseBatchFees is the total amount earned in fees.
	LeaseBatchFees btcutil.Amount

	// LeaseBatchFees is the total amount earned in fees in USD.
	LeaseBatchFeesInUSD decimal.Decimal

	// LSAT is the total amount earned in LSAT tickets.
	LSAT btcutil.Amount

	// LSATInUSD is the total amount earned in LSAT tickets in USD.
	LSATInUSD decimal.Decimal

	//
	// Direct Costs are the costs derived from running the auctioneer.
	//

	// ChainFees is the amount we paid in on-chain fees.
	ChainFees btcutil.Amount

	// ChainFees is the amount we paid in on-chain fees in USD.
	ChainFeesInUSD decimal.Decimal

	// Net Revenue is (Gross Revenue - Direct Costs)
	NetRevenue btcutil.Amount

	// Net Revenue is (Gross Revenue - Direct Costs) in USD.
	NetRevenueInUSD decimal.Decimal
}

// Report contains all the financial data needed by accounting for our pool
// services in a given period of time.
type Report struct {

	// BatchEntries contain the information of every transaction included in
	// the report.
	BatchEntries []*BatchEntry

	// LSATEntries contain the information of every LSAT token sold.
	LSATEntries []*LSATEntry

	// Summary contains the most relevant information of the report.
	Summary Summary
}

// CreateReport creates an accounting report for a given period of time.
func CreateReport(cfg *Config) (*Report, error) {
	ctx := context.Background()

	batches, err := cfg.GetBatches(ctx)
	if err != nil {
		return nil, err
	}

	report := &Report{
		Summary: Summary{
			CreationTime: time.Now(),
			Start:        cfg.Start,
			End:          cfg.End,
		},
		BatchEntries: make([]*BatchEntry, 0, len(batches)),
		LSATEntries:  make([]*LSATEntry, 0),
	}

	// Populate batch entries
	for batchID, snapshot := range batches {
		batchEntry, err := extractBatchEntry(cfg, batchID, snapshot)
		if err != nil {
			log.Info(err)
			return nil, err
		}
		report.BatchEntries = append(report.BatchEntries, batchEntry)
	}

	invoices, err := getLSATInvoices(ctx, cfg)
	if err != nil {
		log.Info(err)
		return nil, err
	}

	// Populate LSAT entries.
	for _, invoice := range invoices {
		lsatEntry, err := extractLSATEntry(cfg, invoice)
		if err != nil {
			log.Info(err)
			return nil, err
		}
		report.LSATEntries = append(report.LSATEntries, lsatEntry)
	}

	// Populate summary data.
	report.CalculateNetRevenue()

	// Populate closing balance at endDate.
	err = report.PopulateClosingBalance(cfg)
	if err != nil {
		return nil, err
	}

	return report, nil
}

// CalculateGrossRevenue populates the sum of all money generated by the
// auctioneer.
func (r *Report) CalculateGrossRevenue() (btcutil.Amount, decimal.Decimal) {
	var (
		leaseBatchFees      btcutil.Amount
		leaseBatchFeesInUSD decimal.Decimal
	)

	for _, entry := range r.BatchEntries {
		leaseBatchFees += entry.AccruedFees

		// We convert it from satoshis to bitcoin => 1 BTC == 100M sats.
		feesInUSD := decimal.New(int64(entry.AccruedFees), -8)
		amt := entry.BTCPrice.Price.Mul(feesInUSD)
		leaseBatchFeesInUSD = leaseBatchFeesInUSD.Add(amt)
	}

	r.Summary.LeaseBatchFees = leaseBatchFees
	r.Summary.LeaseBatchFeesInUSD = leaseBatchFeesInUSD

	var (
		LSAT      btcutil.Amount
		LSATInUSD decimal.Decimal
	)
	for _, entry := range r.LSATEntries {
		LSAT += entry.ProfitInSats

		LSATInUSD = LSATInUSD.Add(entry.ProfitInUSD)
	}

	r.Summary.LSAT = LSAT
	r.Summary.LSATInUSD = LSATInUSD

	total := leaseBatchFees + LSAT
	totalInUSD := r.Summary.LeaseBatchFeesInUSD.Add(r.Summary.LSATInUSD)
	return total, totalInUSD
}

// CalculateDirectCosts populates the sum of all costs accrued by the
// auctioneer.
func (r *Report) CalculateDirectCosts() (btcutil.Amount, decimal.Decimal) {
	var (
		chainFees      btcutil.Amount
		chainFeesInUSD decimal.Decimal
	)

	for _, entry := range r.BatchEntries {
		fees := entry.BatchTxFees - entry.TraderChainFees

		chainFees += fees

		feesInBTC := decimal.New(int64(fees), -8)
		amt := feesInBTC.Mul(entry.BTCPrice.Price)
		chainFeesInUSD = chainFeesInUSD.Add(amt)
	}

	r.Summary.ChainFees = chainFees
	r.Summary.ChainFeesInUSD = chainFeesInUSD

	return r.Summary.ChainFees, r.Summary.ChainFeesInUSD
}

// CalculateNetRevenue populates the earns in a given period after any
// purchaser discounts or allowances are factored.
func (r *Report) CalculateNetRevenue() {
	earnings, earningsInUSD := r.CalculateGrossRevenue()
	costs, costsInUSD := r.CalculateDirectCosts()

	r.Summary.NetRevenue = earnings - costs
	r.Summary.NetRevenueInUSD = earningsInUSD.Sub(costsInUSD)
}

// PopulateCurrentBalance sets the current auctioneer balance and its value
// in USD in the report.
func (r *Report) PopulateClosingBalance(cfg *Config) error {
	ctx := context.Background()

	balance, err := cfg.GetAuctioneerBalance(ctx, r.Summary.End)
	if err != nil {
		return fmt.Errorf("unable to get auctioneer diff for date %v: "+
			"%v", r.Summary.End, err)
	}

	btcPrice, err := cfg.GetPrice(r.Summary.End)
	if err != nil {
		return fmt.Errorf("unable to get price: %v", err)
	}

	balanceInMsat := lnwire.NewMSatFromSatoshis(balance)
	balanceInUSD := fiat.MsatToFiat(btcPrice.Price, balanceInMsat)

	r.Summary.ClosingBalance = balance
	r.Summary.ClosingBalanceInUSD = balanceInUSD
	return nil
}
