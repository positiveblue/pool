syntax = "proto3";

import "auctioneerrpc/auctioneer.proto";

package adminrpc;

option go_package = "github.com/lightninglabs/subasta/adminrpc";

service AuctionAdmin {
    rpc MasterAccount (EmptyRequest) returns (MasterAccountResponse);
    rpc ConnectedTraders (EmptyRequest) returns (ConnectedTradersResponse);
    rpc BatchTick (EmptyRequest) returns (EmptyResponse);
    rpc PauseBatchTicker (EmptyRequest) returns (EmptyResponse);
    rpc ResumeBatchTicker (EmptyRequest) returns (EmptyResponse);
    rpc ListOrders (ListOrdersRequest) returns (ListOrdersResponse);
    rpc AccountDetails (AccountDetailsRequest) returns (Account);
    rpc ListAccounts (EmptyRequest) returns (ListAccountsResponse);
    rpc EditAccount (EditAccountRequest) returns (Account);
    rpc DeleteAccountDiff (DeleteAccountDiffRequest) returns (EmptyResponse);
    rpc AuctionStatus (EmptyRequest) returns (AuctionStatusResponse);
    rpc ListBatches (EmptyRequest) returns (ListBatchesResponse);
    rpc BatchSnapshot (poolrpc.BatchSnapshotRequest)
        returns (AdminBatchSnapshotResponse);
    rpc ListBans (EmptyRequest) returns (ListBansResponse);
    rpc RemoveBan (RemoveBanRequest) returns (EmptyResponse);
    rpc AddBan (BanRequest) returns (EmptyResponse);
    rpc RemoveReservation (RemoveReservationRequest) returns (EmptyResponse);
    rpc FundingConflicts (EmptyRequest) returns (FundingConflictsResponse);
    rpc ClearConflicts (EmptyRequest) returns (EmptyResponse);
    rpc BumpBatchFeeRate (BumpBatchFeeRateRequest) returns (EmptyResponse);
    rpc QueryNodeRating (RatingQueryRequest) returns (RatingQueryResponse);
    rpc ModifyNodeRatings (ModifyRatingRequest) returns (ModifyRatingResponse);
    rpc ListNodeRatings (EmptyRequest) returns (ListNodeRatingsResponse);
    rpc StoreLeaseDuration (LeaseDuration) returns (EmptyResponse);
    rpc RemoveLeaseDuration (LeaseDuration) returns (EmptyResponse);
    rpc MoveFunds (MoveFundsRequest) returns (EmptyResponse);
    rpc ListTraderTerms (EmptyRequest) returns (ListTraderTermsResponse);
    rpc StoreTraderTerms (TraderTerms) returns (EmptyResponse);
    rpc RemoveTraderTerms (TraderTerms) returns (EmptyResponse);
    rpc FinancialReport (FinancialReportRequest)
        returns (FinancialReportResponse);
    rpc Shutdown (EmptyRequest) returns (EmptyResponse);
    rpc SetStatus (SetStatusRequest) returns (EmptyResponse);
    rpc SetLogLevel (SetLogLevelRequest) returns (EmptyResponse);
}

message EmptyRequest {
}

message EmptyResponse {
}

message MasterAccountResponse {
    /*
    OutPoint is the outpoint of the master account. If this is a zero outpoint,
    then no account exists yet.
    */
    OutPoint outpoint = 1;

    /*
    Balance is the current balance of the master account.
    */
    int64 balance = 2;

    /*
    AuctioneerKey is the base key for the auctioneer, this is a static parameter
    that's created when the system is initialized.
    */
    KeyDescriptor key_descriptor = 3;

    /*
    BatchKey is the current batch key for the auctioneer's account, this will be
    incremented by one each batch.
    */
    bytes batch_key = 4;

    // Whether the master account is pending its confirmation.
    bool pending = 5;

    // Current version of the auctioneer account.
    int32 version = 6;
}

message ConnectedTradersResponse {
    /*
    A map of all connected trader streams. The key is the hex-encoded LSAT ID
    of a connected stream and the content is a list of all account keys that
    trader connection has sent subscriptions for.
    */
    map<string, PubKeyList> streams = 1;
}

message PubKeyList {
    /*
    The raw bytes of the key being identified.
    */
    repeated bytes raw_key_bytes = 1;
}

message OutPoint {
    /*
    Raw bytes representing the transaction id.
    */
    bytes txid = 1;

    /*
    The index of the output on the transaction.
    */
    uint32 output_index = 2;
}

message KeyLocator {
    // The family of key being identified.
    int32 key_family = 1;

    // The precise index of the key being identified.
    int32 key_index = 2;
}

message KeyDescriptor {
    /*
    The raw bytes of the key being identified.
    */
    bytes raw_key_bytes = 1;

    /*
    The key locator that identifies which key to use for signing.
    */
    KeyLocator key_loc = 2;
}

message ListOrdersRequest {
    // Indicate whether all archived or all open orders should be returned.
    bool archived = 1;
}

message ListOrdersResponse {
    repeated ServerAsk asks = 1;
    repeated ServerBid bids = 2;
}

message ServerAsk {
    /*
    The common fields shared between both ask and bid order types.
    */
    poolrpc.ServerOrder details = 1;

    /*
    The number of blocks the liquidity provider is willing to provide the
    channel funds for.
    */
    uint32 lease_duration_blocks = 2;

    /*
    The version of the order format that is used. Will be increased once new
    features are added.
    */
    uint32 version = 3;

    /*
    The state the order currently is in.
    */
    poolrpc.OrderState state = 4;

    /*
    The user agent string this order was submitted with.
    */
    string user_agent = 5;
}

message ServerBid {
    /*
    The common fields shared between both ask and bid order types.
    */
    poolrpc.ServerOrder details = 1;

    /*
    Required number of blocks that a channel opened as a result of this bid
    should be kept open.
    */
    uint32 lease_duration_blocks = 2;

    /*
    The version of the order format that is used. Will be increased once new
    features are added.
    */
    uint32 version = 3;

    /*
    The state the order currently is in.
    */
    poolrpc.OrderState state = 4;

    /*
    The minimum node tier this order should be matched with. Only asks backed by
    a node this tier or higher will be eligible for matching with this bid.
    */
    poolrpc.NodeTier min_node_tier = 5;

    /*
    The user agent string this order was submitted with.
    */
    string user_agent = 6;

    /*
    The initial self balance that was chosen by the user for this bid.
    */
    uint64 self_chan_balance = 7;

    /*
    Whether this bid was submitted as a sidecar order.
    */
    bool is_sidecar = 8;
}

message AccountDetailsRequest {
    // The identifying key of the account to retrieve.
    bytes account_key = 1;

    /*
    Whether the account diff, if any, should be retrieved instead of the main
    account state.
    */
    bool include_diff = 2;
}

message EditAccountRequest {
    // The identifying key of the account to edit details of.
    bytes account_key = 1;

    /*
    Whether the account diff, if any, should be edited instead of the main
    account state.
    */
    bool edit_diff = 2;

    // The new value of the account.
    uint64 value = 3;

    /*
    Determines how many times we should rotate the account's current batch key.
    Negative integers decrement the key, while positive increments it.
    */
    int32 rotate_batch_key = 4;

    // The new outpoint of the account.
    OutPoint outpoint = 5;

    // The new latest transaction of the account.
    bytes latest_tx = 6;
}

message DeleteAccountDiffRequest {
    // The identifying key of the account to delete the staged diff of.
    bytes account_key = 1;
}

message ListAccountsResponse {
    repeated Account accounts = 1;
}

message Account {
    /*
    The value of the account in satoshis. Must match the amount of the
    account_point output.
    */
    uint64 value = 1;

    /*
    The block height at which the account should expire.
    */
    uint32 expiry = 2;

    /*
    The trader's account key.
    */
    bytes trader_key = 3;

    /*
    The long term auctioneer's account key.
    */
    bytes auctioneer_key = 4;

    /*
    The current batch key used to create the account output.
    */
    bytes batch_key = 5;

    /*
    The current state of the account as the auctioneer sees it.
    */
    poolrpc.AuctionAccountState state = 6;

    /*
    The block height of the last change to the account's output. Can be used to
    scan the chain for the output's spend state more efficiently.
    */
    uint32 height_hint = 7;

    /*
    Transaction output of the account. Depending on the state of the account,
    this output might have been spent.
    */
    string outpoint = 8;

    /*
    The latest transaction of an account. This is only known by the auctioneer
    after the account has met its initial funding confirmation.
    */
    bytes latest_tx = 9;

    /*
    The user agent string this order was submitted with.
    */
    string user_agent = 10;

    /*
    The account version.
    */
    uint32 version = 11;
}

message AuctionStatusResponse {
    // The ID of the current pending batch.
    bytes pending_batch_id = 1;

    // The ID of the current, not yet published batch.
    bytes current_batch_id = 2;

    // The ID of the last published batch.
    bytes last_batch_id = 3;

    /*
    Indicates whether timed ticks are currently being used to start new batches.
    If this is false, it means batch execution has been paused.
    */
    bool batch_ticker_active = 4;

    /*
    The unix timestamp of the last timed tick. This doesn't necessarily mean
    that the tick also resulted in a batch being executed, for example if the
    batch ticker was paused at the time of the timed tick.
    */
    uint64 last_timed_tick = 5;

    /*
    The number of seconds it will approximately take until the next timed tick
    is fired. The tick will be fired in any case but it might not result in a
    batch being executed if batch execution is currently paused.
    */
    uint64 seconds_to_next_tick = 6;

    /*
    The string representation of the current auctioneer's state.
    */
    string auction_state = 7;

    /*
    The set of lease durations the market is currently accepting and the state
    the duration buckets currently are in.
    */
    map<uint32, poolrpc.DurationBucketState> lease_duration_buckets = 8;

    /*
    The current server state as exposed through the k8s status endpoint.
    */
    string server_state = 9;

    /*
    The estimated fee rate that will be used for the next batch. This might be
    a manually bumped fee rate or an estimation based on the current mempool
    state.
    */
    uint32 next_batch_fee_rate_sat_per_kw = 10;
}

message ListBatchesResponse {
    /*
    A list of all batch IDs known to exist, listed in ascending order (oldest
    batch first) with the last item being the current, not yet published batch.
    */
    repeated bytes batches = 1;
}

message FeeReport {
    // The diffs of all accounts involved in the batch.
    map<string, AccountDiff> account_diffs = 1;

    // The total number of satoshis we earned as the auctioneer.
    uint64 auctioneer_fees_accrued = 2;
}

message AccountDiff {
    // The account key this diff refers to.
    bytes account_key = 1;

    // The balance the trader account started with.
    uint64 starting_balance = 2;

    // The ending balance of the trader's account.
    uint64 ending_balance = 3;

    // The total amount of fees a trader paid to the venue.
    uint64 total_exec_fees_paid = 4;

    /*
    The total amount of fees the trader paid to purchase any channels in this
    batch.
    */
    uint64 total_taker_fees_paid = 5;

    /*
    The total amount of fees the trader gained by selling channels in this
    batch.
    */
    uint64 total_maker_fees_paid = 6;

    /*
    The number of new channels that were created for one account in a batch.
    This is needed to calculate the chain fees that need to be paid from that
    account.
    */
    uint32 num_chans_created = 7;
}

message ListBansResponse {
    /*
    A map of all banned accounts, keyed by the trader's account key (hex
    encoded).
    */
    map<string, BanInfo> banned_accounts = 1;

    /*
    A map of all banned nodes, keyed by the node's identity pubkey (hex
    encoded).
    */
    map<string, BanInfo> banned_nodes = 2;
}

message BanInfo {
    // The height at which the ban begins to apply.
    uint32 height = 1;

    // The number of blocks the ban will last for once applied.
    uint32 duration = 2;
}

message RemoveBanRequest {
    oneof ban {
        // Remove the ban of an account, identified by the trader's account key.
        bytes account = 1;

        // Remove the ban of a node, identified by the node's identity pubkey.
        bytes node = 2;
    }
}

message BanRequest {
    oneof ban {
        // Ban an account, identified by the trader's account key.
        bytes account = 1;

        // Ban a node, identified by the node's identity pubkey.
        bytes node = 2;
    }

    // The number of blocks the ban will last for once applied.
    uint32 duration = 3;
}

message AdminMatchedOrderSnapshots {
    // The list of matched order snapshots.
    repeated AdminMatchedOrderSnapshot snapshots = 1;
}

message AdminMatchedOrderSnapshot {
    // The full ask order that was matched.
    poolrpc.ServerAsk ask = 1;

    // The full bid order that was matched.
    poolrpc.ServerBid bid = 2;

    // The fixed rate premium that was matched, expressed in parts-ber-billion.
    uint32 matching_rate = 3;

    // The total number of satoshis that were bought.
    uint64 total_sats_cleared = 4;

    // The total number of units that were matched.
    uint32 units_matched = 5;
}

message AdminBatchSnapshotResponse {
    // The version of the batch.
    uint32 version = 1;

    // The unique identifier of the batch.
    bytes batch_id = 2;

    // The unique identifier of the prior batch.
    bytes prev_batch_id = 3;

    /*
    The uniform clearing price rate in parts per billion of the batch, mapped
    to the duration of the sub batch.
    */
    map<uint32, uint32> clearing_price_rate = 4;

    // The map of all sub batch lease durations and the orders matched in them.
    map<uint32, AdminMatchedOrderSnapshots> matched_orders = 5;

    // The txid of the batch transaction.
    string batch_tx_id = 7;

    // The batch transaction including all witness data.
    bytes batch_tx = 6;

    // The unix timestamp in nanoseconds the batch was made.
    uint64 creation_timestamp_ns = 8;
}

message RemoveReservationRequest {
    oneof reservation {
        /*
        Remove the reservation of an account, identified by the trader's account
        key.
        */
        bytes trader_key = 1;

        // Remove the reservation of an LSAT, identified by the LSAT's token ID.
        bytes lsat = 2;
    }
}

message FundingConflictsResponse {
    /*
    A map that is keyed by the hex encoded node ID of the reporting node and a
    list of all conflicts that node reported.
    */
    map<string, ConflictList> conflicts = 1;
}

message ConflictList {
    // The list of all reported conflicts.
    repeated Conflict conflicts = 1;
}

message Conflict {
    // The hex encoded node ID of the subject of the report.
    string subject = 1;

    // The reported reason for the conflict.
    string reason = 2;

    // The unix timestamp in seconds of the time the conflict was reported.
    int64 report_timestamp = 3;
}

message RatingQueryRequest {
    // The node to query a rating for.
    bytes node_key = 1;
}
message RatingQueryResponse {
    // The node this rating belongs to.
    bytes node_key = 1;

    // The ratings tier this node belongs to. zero means they aren't ranked.
    uint32 node_tier = 2;
}

message ModifyRatingRequest {
    // The node this rating belongs to.
    bytes node_key = 1;

    // The new node tier this node should be placed in.
    uint32 new_node_tier = 2;
}

message ModifyRatingResponse {
}

message BumpBatchFeeRateRequest {
    // Request the next batch transaction to bump the effective fee rate of all
    // unconfirmed batches to a fee estimate for this confirmation target.
    uint32 conf_target = 1;

    // Request the next batch transaction to bump the effective fee rate of all
    // unconfirmed batches to this exact fee rate.
    uint32 fee_rate_sat_per_kw = 2;

    // Request the next batch transaction to bump the effective fee rate of all
    // unconfirmed batches to this approximate fee rate expressed in sat/vByte.
    uint32 fee_rate_sat_per_vbyte = 3;
}

message NodeRating {
    bytes node_key = 1;

    uint32 node_tier = 2;
}

message ListNodeRatingsResponse {
    repeated NodeRating node_ratings = 1;
}

message LeaseDuration {
    uint32 duration = 1;

    poolrpc.DurationBucketState bucket_state = 2;
}

message Input {
    OutPoint outpoint = 1;
    uint64 value = 2;
    string pk_script = 3;
}

message Output {
    string address = 1;
    uint64 value = 2;
}

message MoveFundsRequest {
    repeated Input inputs = 1;
    repeated Output outputs = 2;
}

message TraderTerms {
    bytes lsat_id = 1;
    int64 base_fee = 2;
    int64 fee_rate = 3;
}

message ListTraderTermsResponse {
    repeated TraderTerms terms = 1;
}

message FinancialReportRequest {
    // The unix timestamp in seconds for the report's starting time.
    int64 start_timestamp = 1;

    // The unix timestamp in seconds for the report's ending time.
    int64 end_timestamp = 2;
}

message BTCPrice {
    // The unix timestamp in seconds.
    int64 timestamp = 1;

    // The fiat price for the given currency for 1 BTC at the given timestamp.
    string price = 2;

    // The code of the currency that the price is quoted in.
    string currency = 3;
}

message FinancialReportBatchEntry {
    // The id of the batch this entry refers to.
    bytes batch_key = 1;

    // The unix timestamp in seconds at which the event occurred.
    int64 timestamp = 2;

    // The txid of the batch transaction.
    string batch_tx_id = 3;

    // The chain fees paid by this batch tx.
    uint64 batch_tx_fees = 4;

    // The total number of satoshis we earned as auctioneer fees.
    uint64 accrued_fees = 5;

    // The total number of satoshis that the participants of the batch paid.
    uint64 trader_chain_fees = 6;

    /*
    The net value earned during the execution of this batch.
    It should match Accrued + TraderChain - BatchChain fees.
    */
    int64 profit_in_sats = 7;

    // The net value earned during the execution of this batch in USD.
    string profit_in_usd = 8;

    // The exchange value used for converting the profit values.
    BTCPrice btc_price = 9;
}

message FinancialReportLSATEntry {
    // The unix timestamp in seconds at which the event occurred.
    int64 timestamp = 1;

    // The net value charged for this LSAT token.
    int64 profit_in_sats = 2;

    /*
    The net value earned during the execution of this batch in USD.
    */
    string profit_in_usd = 3;

    // The exchange value used for converting the profit values.
    BTCPrice btc_price = 4;
}

message FinancialReportSummary {
    // The unix timestamp in seconds for the report's creation time.
    int64 creation_timestamp = 1;

    // The unix timestamp in seconds for the report's starting time.
    int64 start_timestamp = 2;

    // The unix timestamp in seconds for the report's ending time.
    int64 end_timestamp = 3;

    // Full balance of the auctioneer at CreationTime.
    int64 closing_balance = 4;

    // Full balance of the auctioneer at CreationTime in USD.
    string closing_balance_in_usd = 5;

    // Total amount earned in fees.
    int64 lease_batch_fees = 6;

    // Total amount earned in fees in USD.
    string lease_batch_fees_in_usd = 7;

    // Total amount earned in LSAT tickets.
    int64 lsat = 8;

    // Total amount earned in LSAT tickets in USD.
    string lsat_in_usd = 9;

    // The amount we paid in on-chain fees.
    int64 chain_fees = 10;

    // The amount we paid in on-chain fees in USD.
    string chain_fees_in_usd = 11;

    // Net revenue as gross revenue - direct costs.
    int64 net_revenue = 12;

    // Net revenue in USD as gross revenue - direct costs.
    string net_revenue_in_usd = 13;
}

message FinancialReportResponse {
    // Deprecated, use summary.start_timestamp.
    int64 start_timestamp = 1;

    // Deprecated, use summary.end_timestamp.
    int64 end_timestamp = 2;

    // The report batch entries.
    repeated FinancialReportBatchEntry batch_entries = 3;

    // The report LSAT entries.
    repeated FinancialReportLSATEntry lsat_entries = 4;

    // Report summary.
    FinancialReportSummary summary = 5;
}

message SetStatusRequest {
    /*
    The current server state to set for the k8s status endpoint.
    */
    string server_state = 1;
}

message SetLogLevelRequest {
    // The new log level to set for the server.
    string log_level = 1;
}
