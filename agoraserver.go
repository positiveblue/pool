package agora

import (
	"crypto/tls"
	"errors"
	"fmt"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"sync"

	"github.com/btcsuite/btcutil"
	"github.com/lightninglabs/agora/client/clmrpc"
	"github.com/lightninglabs/kirin/auth"
	"github.com/lightninglabs/loop/lndclient"
	"github.com/lightningnetwork/lnd/build"
	"github.com/lightningnetwork/lnd/cert"
	"github.com/lightningnetwork/lnd/lnrpc"
	"golang.org/x/crypto/acme/autocert"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
)

// Start runs agoraserver in daemon mode. It will listen for grpc connections,
// execute commands and pass back auction status information.
func Start(cfg *Config) error {
	// Special show command to list supported subsystems and exit.
	if cfg.DebugLevel == "show" {
		fmt.Printf("Supported subsystems: %v\n",
			logWriter.SupportedSubsystems())
		os.Exit(0)
	}

	// Append the network type to the log directory so it is
	// "namespaced" per network in the same fashion as the data directory.
	cfg.LogDir = filepath.Join(cfg.LogDir, cfg.Network)

	// Initialize logging at the default logging level.
	err := logWriter.InitLogRotator(
		filepath.Join(cfg.LogDir, defaultLogFilename),
		cfg.MaxLogFileSize, cfg.MaxLogFiles,
	)
	if err != nil {
		return err
	}
	err = build.ParseAndSetDebugLevels(cfg.DebugLevel, logWriter)
	if err != nil {
		return err
	}

	lndServices, err := lndclient.NewLndServices(
		cfg.Lnd.Host, cfg.Network, cfg.Lnd.MacaroonDir, cfg.Lnd.TLSPath,
	)
	if err != nil {
		return err
	}
	defer lndServices.Close()

	auctioneerServer, err := NewEtcdServer(
		&lndServices.LndServices, cfg.Etcd.Host, cfg.Etcd.User,
		cfg.Etcd.Password, btcutil.Amount(cfg.OrderSubmitFee),
	)
	if err != nil {
		return err
	}

	interceptor := auth.ServerInterceptor{}
	serverOpts := []grpc.ServerOption{
		grpc.UnaryInterceptor(interceptor.UnaryInterceptor),
	}
	switch {
	// If auto cert is cfgured, then we'll create a cert automatically
	// using Let's Encrypt.
	case !cfg.Insecure && cfg.AutoCert:
		serverName := cfg.ServerName
		if serverName == "" {
			return errors.New("servername option is required for " +
				"secure operation")
		}

		certDir := filepath.Join(cfg.BaseDir, "autocert")
		log.Infof("Configuring autocert for server %v and cache dir %v",
			serverName, certDir)

		manager := autocert.Manager{
			Cache:      autocert.DirCache(certDir),
			Prompt:     autocert.AcceptTOS,
			HostPolicy: autocert.HostWhitelist(serverName),
		}

		go func() {
			err := http.ListenAndServe(
				":http", manager.HTTPHandler(nil),
			)
			if err != nil {
				log.Errorf("autocert http: %v", err)
			}
		}()
		tlsConf := &tls.Config{
			GetCertificate: manager.GetCertificate,
		}

		sCreds := credentials.NewTLS(tlsConf)
		serverOpts = append(serverOpts, grpc.Creds(sCreds))

	// Otherwise, we'll generate custom self-signed cets.
	case !cfg.Insecure:
		// Ensure we create TLS key and certificate if they don't exist
		if !lnrpc.FileExists(cfg.TLSCertPath) &&
			!lnrpc.FileExists(cfg.TLSKeyPath) {

			err := cert.GenCertPair(
				"agora autogenerated cert", cfg.TLSCertPath,
				cfg.TLSKeyPath, nil, nil,
				cert.DefaultAutogenValidity,
			)
			if err != nil {
				return err
			}
		}
		certData, _, err := cert.LoadCert(
			cfg.TLSCertPath, cfg.TLSKeyPath,
		)
		if err != nil {
			return err
		}
		sCreds := credentials.NewTLS(cert.TLSConfFromCert(certData))
		serverOpts = append(serverOpts, grpc.Creds(sCreds))
	}

	grpcServer := grpc.NewServer(serverOpts...)
	clmrpc.RegisterChannelAuctioneerServerServer(
		grpcServer, auctioneerServer,
	)

	// Next, Start the gRPC server listening for HTTP/2 connections.
	log.Infof("Starting gRPC listener")
	grpcListener := cfg.RPCListener
	if grpcListener == nil {
		grpcListener, err = net.Listen("tcp", defaultAuctioneerAddr)
		if err != nil {
			return fmt.Errorf("RPC server unable to listen on %s",
				defaultAuctioneerAddr)
		}
		defer grpcListener.Close()
	}

	// Start the auctioneer server itself.
	err = auctioneerServer.Start()
	if err != nil {
		return fmt.Errorf("unable to start agora server: %v", err)
	}

	// Start the grpc server.
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()

		log.Infof("RPC server listening on %s", grpcListener.Addr())
		_ = grpcServer.Serve(grpcListener)
	}()

	// Run until the user terminates agoraserver.
	<-cfg.ShutdownChannel
	log.Info("Received shutdown signal, stopping server")
	grpcServer.GracefulStop()
	err = auctioneerServer.Stop()
	if err != nil {
		log.Errorf("error shutting down server: %v", err)
	}

	wg.Wait()
	return nil
}
